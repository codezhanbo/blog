<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>关于设计模式 | 麋鹿的博客</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/favicon.ico">
    <meta name="description" content="读书破万卷，下笔如有神">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/assets/css/0.styles.ce9a728b.css" as="style"><link rel="preload" href="/assets/js/app.99643522.js" as="script"><link rel="preload" href="/assets/js/3.6a376a2c.js" as="script"><link rel="preload" href="/assets/js/1.3b62a509.js" as="script"><link rel="preload" href="/assets/js/18.ab53c384.js" as="script"><link rel="prefetch" href="/assets/js/10.3316d455.js"><link rel="prefetch" href="/assets/js/11.457f28d9.js"><link rel="prefetch" href="/assets/js/12.3e24f86c.js"><link rel="prefetch" href="/assets/js/13.599c9331.js"><link rel="prefetch" href="/assets/js/14.8cf8dbd3.js"><link rel="prefetch" href="/assets/js/15.b4038936.js"><link rel="prefetch" href="/assets/js/16.c910a26b.js"><link rel="prefetch" href="/assets/js/17.f3f0fe34.js"><link rel="prefetch" href="/assets/js/19.e254f100.js"><link rel="prefetch" href="/assets/js/20.264491e0.js"><link rel="prefetch" href="/assets/js/21.7e517865.js"><link rel="prefetch" href="/assets/js/4.6c8c719b.js"><link rel="prefetch" href="/assets/js/5.d2cf410c.js"><link rel="prefetch" href="/assets/js/6.3629d31c.js"><link rel="prefetch" href="/assets/js/7.df04ee3d.js"><link rel="prefetch" href="/assets/js/8.9eb7627a.js"><link rel="prefetch" href="/assets/js/9.28ead82b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ce9a728b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-19557b78><div data-v-19557b78><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-19557b78 data-v-19557b78><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-19557b78 data-v-19557b78><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>麋鹿的博客</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>麋鹿</span>
            
          <span data-v-64685f0e>2019 - </span>
          2020
        </a></span></div></div> <div class="hide" data-v-19557b78><header class="navbar" data-v-19557b78><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516123335.png" alt="麋鹿的博客" class="logo"> <span class="site-name">麋鹿的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/生活/" class="nav-link"><i class="iconfont undefined"></i>
  生活
</a></li><li class="dropdown-item"><!----> <a href="/categories/编程基础/" class="nav-link"><i class="iconfont undefined"></i>
  编程基础
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/categories/技术类/" class="nav-link"><i class="iconfont undefined"></i>
  技术类
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/zhanbo136" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/IMG_6115%2820200513-225754%29.JPG" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-wechat"></i>
  微信
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Sdramsfagfqeg" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  csdn
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-19557b78></div> <aside class="sidebar" data-v-19557b78><div class="personal-info-wrapper" data-v-4b1e0b85><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516120700.jpg" alt="author-avatar" class="personal-img" data-v-4b1e0b85> <h3 class="name" data-v-4b1e0b85>
    麋鹿
  </h3> <div class="num" data-v-4b1e0b85><div data-v-4b1e0b85><h3 data-v-4b1e0b85>10</h3> <h6 data-v-4b1e0b85>文章</h6></div> <div data-v-4b1e0b85><h3 data-v-4b1e0b85>8</h3> <h6 data-v-4b1e0b85>标签</h6></div></div> <hr data-v-4b1e0b85></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/生活/" class="nav-link"><i class="iconfont undefined"></i>
  生活
</a></li><li class="dropdown-item"><!----> <a href="/categories/编程基础/" class="nav-link"><i class="iconfont undefined"></i>
  编程基础
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/categories/技术类/" class="nav-link"><i class="iconfont undefined"></i>
  技术类
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/zhanbo136" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/IMG_6115%2820200513-225754%29.JPG" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-wechat"></i>
  微信
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Sdramsfagfqeg" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-csdn"></i>
  csdn
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>关于设计模式</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/views/java/design/mode.html#_1、设计模式七大原则" class="sidebar-link">1、设计模式七大原则</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/java/design/mode.html#_2、uml类图" class="sidebar-link">2、UML类图</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_2-1类之间的关系：" class="sidebar-link">2.1类之间的关系：</a></li></ul></li><li><a href="/views/java/design/mode.html#_3、-设计模式类型" class="sidebar-link">3、 设计模式类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-1、单例模式" class="sidebar-link">3.1、单例模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-2、工厂模式" class="sidebar-link">3.2、工厂模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-3、原型模式" class="sidebar-link">3.3、原型模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-4、建造者模式" class="sidebar-link">3.4、建造者模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-5、适配器模式" class="sidebar-link">3.5、适配器模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-6、桥接模式" class="sidebar-link">3.6、桥接模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-7、装饰者设计模式" class="sidebar-link">3.7、装饰者设计模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-8、组合模式" class="sidebar-link">3.8、组合模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-9、外观模式" class="sidebar-link">3.9、外观模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-10、享元模式" class="sidebar-link">3.10、享元模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-11、代理模式" class="sidebar-link">3.11、代理模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-12、模板方法模式" class="sidebar-link">3.12、模板方法模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-13、命令模式" class="sidebar-link">3.13、命令模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-14、访问者模式" class="sidebar-link">3.14、访问者模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-15、迭代器模式" class="sidebar-link">3.15、迭代器模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-16、观察者模式" class="sidebar-link">3.16、观察者模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-17、中介者模式" class="sidebar-link">3.17、中介者模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-18、备忘录模式" class="sidebar-link">3.18、备忘录模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-19、解释器模式" class="sidebar-link">3.19、解释器模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-20、状态模式" class="sidebar-link">3.20、状态模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-21、策略模式" class="sidebar-link">3.21、策略模式</a></li><li class="sidebar-sub-header"><a href="/views/java/design/mode.html#_3-22、职责链模式" class="sidebar-link">3.22、职责链模式</a></li></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-19557b78><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>关于设计模式</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>麋鹿</span>
            
          <span data-v-64685f0e>2019 - </span>
          2020
        </a></span></div></div> <div data-v-19557b78><main class="page"><div class="page-title" style="display:none;"><h1>关于设计模式</h1> <hr> <div data-v-cd8d63d2><i class="iconfont reco-account" data-v-cd8d63d2><span data-v-cd8d63d2>麋鹿</span></i> <i class="iconfont reco-date" data-v-cd8d63d2><span data-v-cd8d63d2>2020-05-14</span></i> <i class="iconfont reco-eye" data-v-cd8d63d2><span id="/views/java/design/mode.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-cd8d63d2><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-cd8d63d2><span class="tag-item" data-v-cd8d63d2>
      设计模式
    </span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h1> <h2 id="_1、设计模式七大原则"><a href="#_1、设计模式七大原则" class="header-anchor">#</a> 1、设计模式七大原则</h2> <ul><li><p>单一职责原则</p></li> <li><p>接口隔离原则</p></li> <li><p>依赖倒转(倒置)原则</p></li> <li><p>里氏替换原则</p></li> <li><p>开闭原则</p></li> <li><p>迪米特法则</p></li> <li><p>合成复用原则</p></li></ul> <h2 id="_2、uml类图"><a href="#_2、uml类图" class="header-anchor">#</a> 2、UML类图</h2> <ul><li>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统 分析和设计的语言工具，它用于帮助软 件开发人员进行思考和记录思路的结果</li> <li>UML本身是一套符号的规定，就像数学 符号和化学符号一样，这些符号用于描 述软件模型中的各个元素和他们之间的 关系，比如类、接口、实现、泛化、依 赖、组合、聚合等，如右图: <img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130011.png" alt="image-20200417104235195"></li> <li>使用UML来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模</li></ul> <h3 id="_2-1类之间的关系："><a href="#_2-1类之间的关系：" class="header-anchor">#</a> 2.1类之间的关系：</h3> <blockquote><p>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系</p></blockquote> <ul><li>依赖</li> <li>泛化（继承）</li> <li>实现</li> <li>关联</li> <li>聚合</li> <li>组合</li></ul> <h2 id="_3、-设计模式类型"><a href="#_3、-设计模式类型" class="header-anchor">#</a> 3、 设计模式类型</h2> <p>设计模式分为三种类型，共23种</p> <ul><li><ol><li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</li></ol></li> <li><ol start="2"><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享 元模式、代理模式。</li></ol></li> <li><ol start="3"><li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模 式、策略模式、职责链模式(责任链模式)。</li></ol></li></ul> <h3 id="_3-1、单例模式"><a href="#_3-1、单例模式" class="header-anchor">#</a> 3.1、单例模式</h3> <ul><li>饿汉式(静态常量)</li> <li>饿汉式（静态代码块）</li> <li>懒汉式(线程不安全)</li> <li>懒汉式(线程安全，同步方法)</li> <li>懒汉式(线程安全，同步代码块)</li> <li>双重检查</li> <li>静态内部类</li> <li>枚举</li></ul> <blockquote><p><strong>饿汉式（静态常量）</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。</li> <li>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费</li> <li>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化instance就没有达到lazy loading的效果</li> <li>结论：这种单例模式可用，可能造成内存浪费</li></ul> <blockquote><p><strong>饿汉式（静态代码块）</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li><ol><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块 中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优 缺点和上面是一样的。</li></ol></li> <li><ol start="2"><li>结论：这种单例模式可用，但是可能造成内存浪费</li></ol></li></ul> <blockquote><p><strong>懒汉式(线程不安全)</strong></p></blockquote> <p><strong>优缺点说明</strong>：</p> <ul><li><ol><li>起到了Lazy Loading的效果，但是只能在单线程下使用。</li></ol></li> <li><ol start="2"><li>如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式 3) 结论：在实际开发中，不要使用这种方式</li></ol></li></ul> <blockquote><p><strong>懒汉式(线程安全，同步方法)</strong></p></blockquote> <p><strong>优缺点说明</strong>：</p> <ul><li><ol><li>解决了线程不安全问题</li></ol></li> <li><ol start="2"><li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低 3) 结论：在实际开发中，不推荐使用这种方式</li></ol></li></ul> <blockquote><p><strong>双重检查</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li><ol><li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次if (singleton == null)检查，这样就可以保证线程安全了。</li></ol></li> <li><ol start="2"><li>这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， 直接return实例化对象，也避免的反复进行方法同步.</li></ol></li> <li><ol start="3"><li>线程安全；延迟加载；效率较高</li></ol></li> <li><ol start="4"><li>结论：在实际开发中，推荐使用这种单例设计模</li></ol></li></ul> <blockquote><p><strong>静态内部类</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li><ol><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li></ol></li> <li><ol start="2"><li>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 实例化。</li></ol></li> <li><ol start="3"><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li></ol></li> <li><ol start="4"><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li></ol></li> <li><ol start="5"><li>结论：推荐使用.</li></ol></li></ul> <blockquote><p><strong>枚举</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li><ol><li>这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 且还能防止反序列化重新创建新的对象。</li></ol></li> <li><ol start="2"><li>这种方式是Effective Java作者Josh Bloch 提倡的方式</li></ol></li> <li><ol start="3"><li>结论：推荐使用</li></ol></li></ul> <h3 id="_3-2、工厂模式"><a href="#_3-2、工厂模式" class="header-anchor">#</a> 3.2、工厂模式</h3> <ul><li>简单工厂模式</li> <li>工厂方法模式</li> <li>抽象工厂模式</li></ul> <blockquote><p><strong>基本介绍</strong>：</p></blockquote> <ul><li><ol><li>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一 个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族 中最简单实用的模式</li></ol></li> <li><ol start="2"><li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行 为(代码)</li></ol></li> <li><ol start="3"><li>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会 使用到工厂模式</li></ol></li></ul> <blockquote><p><strong>工厂方法模式</strong></p></blockquote> <p>工厂方法模式介绍</p> <ul><li>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点 餐子类中具体实现。</li> <li>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方 法模式将对象的实例化推迟到子类。</li></ul> <blockquote><p><strong>抽象工厂模式</strong></p></blockquote> <ul><li><ol><li>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需 指明具体的类</li></ol></li> <li><ol start="2"><li>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li></ol></li> <li><ol start="3"><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</li></ol></li> <li><ol start="4"><li>将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以 根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇， 更利于代码的维护和扩展。</li></ol></li></ul> <p><strong>工厂模式小结</strong>：</p> <ul><li><ol><li>工厂模式的意义 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的 依赖关系的解耦。从而提高项目的扩展和维护性。</li></ol></li> <li><ol start="2"><li>三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)</li></ol></li> <li><ol start="3"><li>设计模式的依赖抽象原</li></ol></li></ul> <h3 id="_3-3、原型模式"><a href="#_3-3、原型模式" class="header-anchor">#</a> 3.3、原型模式</h3> <blockquote><p><strong>基本介绍</strong>：</p></blockquote> <ul><li><ol><li>原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷 贝这些原型，创建新的对象</li></ol></li> <li><ol start="2"><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节</li></ol></li> <li><ol start="3"><li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建 的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()</li></ol></li> <li><ol start="4"><li>形象的理解：孙大圣拔出猴毛， 变出其它孙大圣</li></ol></li></ul> <blockquote><p><strong>原型模式原理结构图-uml类图：</strong></p></blockquote> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130030.png" alt="image-20200417221010897"></p> <blockquote><p><strong>原理结构图说明</strong> ：</p></blockquote> <ul><li><ol><li>Prototype : 原型类，声明一个克隆自己的接口</li></ol></li> <li><ol start="2"><li>ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作</li></ol></li> <li><ol start="3"><li>Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)</li></ol></li></ul> <p><strong>深入讨论-浅拷贝和深拷贝</strong></p> <blockquote><p><strong>浅拷贝的介绍：</strong></p></blockquote> <ul><li><ol><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将 该属性值复制一份给新的对象。</li></ol></li> <li><ol start="2"><li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类 的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内 存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个 实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成 员变量值</li></ol></li> <li><ol start="3"><li>前面我们克隆羊就是浅拷贝</li></ol></li> <li><ol start="4"><li>浅拷贝是使用默认的 clone()方法来实现 sheep = (Sheep) super.clone();</li></ol></li></ul> <blockquote><p><strong>深拷贝基本介绍：</strong></p></blockquote> <ul><li><ol><li>复制对象的所有基本数据类型的成员变量值</li></ol></li> <li><ol start="2"><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变 量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对 整个对象进行拷贝。</li></ol></li> <li><ol start="3"><li>深拷贝实现方式1：重写clone方法来实现深拷贝</li></ol></li> <li><ol start="4"><li>深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)</li></ol></li></ul> <blockquote><p><strong>原型模式的注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提 高效率</li></ol></li> <li><ol start="2"><li>不用重新初始化对象，而是动态地获得对象运行时的状态</li></ol></li> <li><ol start="3"><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化， 无需修改代码</li></ol></li> <li><ol start="4"><li>在实现深克隆的时候可能需要比较复杂的代码</li></ol></li> <li><ol start="5"><li>缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有 的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意.</li></ol></li></ul> <h3 id="_3-4、建造者模式"><a href="#_3-4、建造者模式" class="header-anchor">#</a> 3.4、建造者模式</h3> <blockquote><p><strong>基本介绍：</strong></p></blockquote> <ul><li><ol><li>建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以 将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方 法可以构造出不同表现（属性）的对象。</li></ol></li> <li><ol start="2"><li>建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象 的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</li></ol></li></ul> <blockquote><p><strong>建造者模式的四个角色：</strong></p></blockquote> <ul><li><ol><li>Product（产品角色）： 一个具体的产品对象。</li></ol></li> <li><ol start="2"><li>Builder（抽象建造者）： 创建一个Product对象的各个部件指定的 接口/抽象类。</li></ol></li> <li><ol start="3"><li>ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。</li></ol></li> <li><ol start="4"><li>Director（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个 复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是： 负责控制产品对象的生产过程</li></ol></li></ul> <blockquote><p><strong>建造者模式原理类图</strong>：</p></blockquote> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130038.png" alt="image-20200417221339283"></p> <blockquote><p><strong>建造者模式的注意事项和细节</strong>：</p></blockquote> <ul><li><ol><li>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解 耦，使得相同的创建过程可以创建不同的产品对象</li></ol></li> <li><ol start="2"><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替 换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同 的产品对象</li></ol></li> <li><ol start="3"><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法 中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</li></ol></li> <li><ol start="4"><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程， 系统扩展方便，符合 “开闭原则”</li></ol></li></ul> <h3 id="_3-5、适配器模式"><a href="#_3-5、适配器模式" class="header-anchor">#</a> 3.5、适配器模式</h3> <p><strong>基本介绍</strong></p> <ul><li><ol><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表 示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同 工作。其别名为包装器(Wrapper)</li></ol></li> <li><ol start="2"><li>适配器模式属于结构型模式</li></ol></li> <li><ol start="3"><li>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</li></ol></li></ul> <blockquote><p><strong>适配器模式工作原理：</strong></p></blockquote> <ul><li><ol><li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼 容</li></ol></li> <li><ol start="2"><li>从用户的角度看不到被适配者，是解耦的</li></ol></li> <li><ol start="3"><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口 方法</li></ol></li> <li><ol start="4"><li>用户收到反馈结果，感觉只是和目标接口交互，如图</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130045.png" alt="image-20200418094510964"></p> <p><strong>类适配器模式</strong></p> <blockquote><p><strong>类适配器模式介绍：</strong></p></blockquote> <ul><li>Adapter类，通过继承 src类，实现 dst 类接口，完成src-&gt;dst的适配。</li></ul> <blockquote><p><strong>类适配器模式注意事项和细节</strong></p></blockquote> <ul><li><ol><li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要 求dst必须是接口，有一定局限性;</li></ol></li> <li><ol start="2"><li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</li></ol></li> <li><ol start="3"><li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵 活性增强了。</li></ol></li></ul> <blockquote><p><strong>类适配器模式注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要 求dst必须是接口，有一定局限性;</li></ol></li> <li><ol start="2"><li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</li></ol></li> <li><ol start="3"><li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵 活性增强了</li></ol></li></ul> <p><strong>对象适配器模式</strong></p> <blockquote><p><strong>对象适配器模式介绍</strong></p></blockquote> <ul><li><ol><li>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而 是持有src类的实例，以解决兼容性的问题。 即：持有 src类，实现 dst 类接口， 完成src-&gt;dst的适配</li></ol></li> <li><ol start="2"><li>根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。</li></ol></li> <li><ol start="3"><li>对象适配器模式是适配器模式常用的一种</li></ol></li></ul> <blockquote><p><strong>对象适配器模式注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承src的 局限性问题，也不再要求dst必须是接口。</li></ol></li> <li><ol start="2"><li>使用成本更低，更灵活。</li></ol></li></ul> <blockquote><p><strong>接口适配器模式介绍：</strong></p></blockquote> <ul><li><ol><li>一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。</li></ol></li> <li><ol start="2"><li>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接 口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆 盖父类的某些方法来实现需求</li></ol></li> <li><ol start="3"><li>适用于一个接口不想使用其所有的方法的情况。</li></ol></li></ul> <blockquote><p><strong>适配器模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来 命名的。</li></ol></li> <li><ol start="2"><li>类适配器：以类给到，在Adapter里，就是将src当做类，继承 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现</li></ol></li> <li><ol start="3"><li>Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</li></ol></li> <li><ol start="4"><li>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</li></ol></li></ul> <h3 id="_3-6、桥接模式"><a href="#_3-6、桥接模式" class="header-anchor">#</a> 3.6、桥接模式</h3> <blockquote><p><strong>基本介绍：</strong></p></blockquote> <ul><li><ol><li>桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层 次可以独立改变。</li></ol></li> <li><ol start="2"><li>是一种结构型设计模式</li></ol></li> <li><ol start="3"><li>Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同 的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现 (Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能 扩展</li></ol></li></ul> <blockquote><p><strong>桥接模式原理类图：</strong></p></blockquote> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130050.png" alt="image-20200418104355271"></p> <blockquote><p><strong>原理类图说明：</strong></p></blockquote> <ul><li><ol><li>Client类：桥接模式的调用者</li></ol></li> <li><ol start="2"><li>抽象类(Abstraction) :维护了 Implementor / 即它的实现类ConcreteImplementorA.., 二者是聚合关系, Abstraction 充当 桥接类</li></ol></li></ul> <blockquote><p><strong>桥接模式的注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实 现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li></ol></li> <li><ol start="2"><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部 分由具体业务来完成。</li></ol></li> <li><ol start="3"><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</li></ol></li> <li><ol start="4"><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层， 要求开发者针对抽象进行设计和编程 5) 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局 限性，即需要有这样的应用场景</li></ol></li></ul> <h3 id="_3-7、装饰者设计模式"><a href="#_3-7、装饰者设计模式" class="header-anchor">#</a> 3.7、装饰者设计模式</h3> <h3 id="_3-8、组合模式"><a href="#_3-8、组合模式" class="header-anchor">#</a> 3.8、组合模式</h3> <blockquote><p>基本介绍：</p></blockquote> <ul><li><ol><li>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结 构，将对象组合成树状结构以表示“整体-部分”的层次关系。</li></ol></li> <li><ol start="2"><li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 3) 这种类型的设计模式属于结构型模式。 4) 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客 户以一致的方式处理个别对象以及组合对象理结构图的说明-即(组合模式的角色及职责)</li></ol></li></ul> <blockquote><p>组合模式的原理类图：</p></blockquote> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130053.png" alt="image-20200510210536399"></p> <ul><li><ol><li>Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子 部件, Component 可以是抽象类或者接口</li></ol></li> <li><ol start="2"><li>Leaf : 在组合中表示叶子节点，叶子节点没有子节点</li></ol></li></ul> <p><strong>解决的问题</strong></p> <blockquote><p>组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而 我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑 它是节点还是叶子 2) 对应的示意图</p></blockquote> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130100.png" alt="image-20200510210610447"></p> <blockquote><p><strong>组合模式在JDK集合的源码分析</strong></p></blockquote> <p><strong>组合模式在JDK集合的源码分析：</strong>
Java的集合类-HashMap就使用了组合模式 2) 代码分析+Debug 源码</p> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130103.png" alt="image-20200510210709009"></p> <blockquote><p><strong>组合模式的注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子 的问题。</li></ol></li> <li><ol start="2"><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系， 客户端不用做出任何改动.</li></ol></li> <li><ol start="3"><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点 或者叶子从而创建出复杂的树形结构</li></ol></li> <li><ol start="4"><li>需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.</li></ol></li> <li><ol start="5"><li>要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性 都不一样，不适合使用组合模式</li></ol></li></ul> <h3 id="_3-9、外观模式"><a href="#_3-9、外观模式" class="header-anchor">#</a> 3.9、外观模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ol><li><p>外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供 一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加 容易使用</p></li> <li><p>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端 只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p></li></ol> <blockquote><p><strong>外观模式原理类图</strong></p></blockquote> <ul><li><ol><li>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当 子系统对象</li></ol></li> <li><ol start="2"><li>调用者(Client): 外观接口的调用者</li></ol></li> <li><ol start="3"><li>子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130107.png" alt="image-20200510210920073"></p> <blockquote><p><strong>外观模式在MyBatis框架应用的源码分析</strong></p></blockquote> <ol><li>MyBatis 中的Configuration 去创建MetaObject 对象使用到外观模式 2) 代码分析+Debug源码+示意图</li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130109.png" alt="image-20200510210954986"></p> <blockquote><p><strong>外观模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复 杂性</li></ol></li> <li><ol start="2"><li>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</li></ol></li> <li><ol start="3"><li>通过合理的使用外观模式，可以帮我们更好的划分访问的层次</li></ol></li> <li><ol start="4"><li>当系统需要进行分层设计时，可以考虑使用Facade模式</li></ol></li> <li><ol start="5"><li>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时 可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 让新系统与Facade类交互，提高复用性</li></ol></li> <li><ol start="6"><li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。 要以让系统有层次，利于维护为目的</li></ol></li></ul> <h3 id="_3-10、享元模式"><a href="#_3-10、享元模式" class="header-anchor">#</a> 3.10、享元模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ul><li><ol><li>享元模式（Flyweight Pattern） 也叫 蝇量模式: 运 用共享技术有效地支持大量细粒度的对象</li></ol></li> <li><ol start="2"><li>常用于系统底层开发，解决系统的性能问题。像 数据库连接池，里面都是创建好的连接对象，在 这些连接对象中有我们需要的则直接拿来用，避 免重新创建，如果没有我们需要的，则创建一个</li></ol></li> <li><ol start="3"><li>享元模式能够解决重复对象的内存浪费的问题， 当系统中有大量相似对象，需要缓冲池时。不需 总是创建新对象，可以从缓冲池里拿。这样可以 降低系统内存，同时提高效率</li></ol></li> <li><ol start="4"><li>享元模式经典的应用场景就是池技术了，String常 量池、数据库连接池、缓冲池等等都是享元模式 的应用，享元模式是池技术的重要实现方式</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130113.png" alt="image-20200510221232579"></p> <blockquote><p><strong>享元模式的原理类图</strong></p></blockquote> <p>对原理图的说明-即(模式的角色及职责)</p> <ul><li><ol><li>FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现</li></ol></li> <li><ol start="2"><li>ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130116.png" alt="image-20200510221247213"></p> <p><strong>内部状态和外部状态</strong></p> <p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一 点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后， 落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p> <ul><li><ol><li>享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态 了，即将对象的信息分为两个部分：内部状态和外部状态</li></ol></li> <li><ol start="2"><li>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</li></ol></li> <li><ol start="3"><li>外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</li></ol></li> <li><ol start="4"><li>举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对 象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用 享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解 决了对象的开销问题</li></ol></li></ul> <blockquote><p><strong>享元模式在JDK-Interger的应用源码分析</strong></p></blockquote> <ul><li><ol><li>Integer中的享元模式</li></ol></li> <li><ol start="2"><li>代码分析+Debug源码+说明</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130120.png" alt="image-20200510221328202"></p> <blockquote><p><strong>享元模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li></ol></li> <li><ol start="2"><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时， 我们就可以考虑选用享元模式</li></ol></li> <li><ol start="3"><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap/HashTable存储</li></ol></li> <li><ol start="4"><li>享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</li></ol></li> <li><ol start="5"><li>享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有 固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的 地方.</li></ol></li> <li><ol start="6"><li>使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。</li></ol></li> <li><ol start="7"><li>享元模式经典的应用场景是需要缓冲池的场景，比如 String常量池、数据库连接池</li></ol></li></ul> <h3 id="_3-11、代理模式"><a href="#_3-11、代理模式" class="header-anchor">#</a> 3.11、代理模式</h3> <blockquote><p><strong>代理模式的基本介绍</strong></p></blockquote> <ul><li><ol><li>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理 对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的 功能操作,即扩展目标对象的功能。</li></ol></li> <li><ol start="2"><li>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</li></ol></li> <li><ol start="3"><li>代理模式有不同的形式, 主要有三种 静态代理、动态代理 (JDK代理、接口代 理)和 Cglib代理 (可以在内存动态的创建对象，而不需要实现接口， 他是属于 动态代理的范畴) 。</li></ol></li></ul> <blockquote><p><strong>静态代码模式的基本介绍</strong></p></blockquote> <p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一 起实现相同的接口或者是继承相同父类，静态代理优缺点。</p> <ul><li><ol><li>优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展</li></ol></li> <li><ol start="2"><li>缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类</li></ol></li> <li><ol start="3"><li>一旦接口增加方法,目标对象与代理对象都要维护</li></ol></li></ul> <blockquote><p><strong>动态代理模式的基本介绍</strong></p></blockquote> <ul><li><ol><li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li></ol></li> <li><ol start="2"><li>代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象</li></ol></li> <li><ol start="3"><li>动态代理也叫做：JDK代理、接口代理</li></ol></li></ul> <blockquote><p><strong>JDK中生成代理对象的API</strong></p></blockquote> <ol><li><p>代理类所在包:java.lang.reflect.Proxy</p></li> <li><p>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完 整的写法是: static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</p></li></ol> <blockquote><p><strong>Cglib代理模式的基本介绍</strong></p></blockquote> <ul><li><ol><li>静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只 是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现 代理-这就是Cglib代理</li></ol></li> <li><ol start="2"><li>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功 能扩展, 有些书也将Cglib代理归属到动态代理。</li></ol></li> <li><ol start="3"><li>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接 口.它广泛的被许多AOP的框架使用,例如Spring AOP，实现方法拦截</li></ol></li> <li><ol start="4"><li>在AOP编程中如何选择代理模式： 1. 目标对象需要实现接口，用JDK代理 2. 目标对象不需要实现接口，用Cglib代理</li></ol></li> <li><ol start="5"><li>Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</li></ol></li></ul> <blockquote><p><strong>几种常见的代理模式介绍— 几种变体</strong></p></blockquote> <ol><li><p>防火墙代理 内网通过代理穿透防火墙，实现对公网的访问。</p></li> <li><p>缓存代理 比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源， 再到公网或者数据库取，然后缓存。</p></li> <li><p>远程代理 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和 真正的远程对象沟通信息。</p></li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130124.png" alt="image-20200513002450830"></p> <ol start="4"><li>同步代理：主要使用在多线程编程中，完成多线程间同步工作</li></ol> <h3 id="_3-12、模板方法模式"><a href="#_3-12、模板方法模式" class="header-anchor">#</a> 3.12、模板方法模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ul><li><ol><li>模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，z 在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法 实现，但调用将以抽象类中定义的方式进行。</li></ol></li> <li><ol start="2"><li>简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子 类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定 步骤</li></ol></li> <li><ol start="3"><li>这种类型的设计模式属于行为型模式。</li></ol></li></ul> <blockquote><p><strong>模板方法模式的原理类图</strong></p></blockquote> <p>对原理类图的说明-即(模板方法模式的角色及职责)</p> <ul><li><ol><li>AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨 架，具体子类需要去实现 其它的抽象方法operationr2,3,4</li></ol></li> <li><ol start="2"><li>ConcreteClass 实现抽象方法operationr2,3,4, 以完成算法中特点子类的步 骤</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130126.png" alt="image-20200513002554173"></p> <blockquote><p><strong>模板方法模式的钩子方法</strong></p></blockquote> <ul><li><ol><li>在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以 视情况要不要覆盖它，该方法称为“钩子”。</li></ol></li> <li><ol start="2"><li>还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配 料，请使用钩子方法对前面的模板方法进行改造</li></ol></li></ul> <p><strong>模板方法模式在Spring框架应用的源码分析</strong></p> <ol><li><p>Spring IOC容器初始化时运用到的模板方法模式</p></li> <li><p>代码分析+角色分析+说明类图</p></li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130129.png" alt="image-20200513002707792"></p> <blockquote><p><strong>模板方法模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算 法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</li></ol></li> <li><ol start="2"><li>实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接 使用。</li></ol></li> <li><ol start="3"><li>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不 变，同时由子类提供部分步骤的实现。</li></ol></li> <li><ol start="4"><li>该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加， 使得系统更加庞大</li></ol></li> <li><ol start="5"><li>一般模板方法都加上final关键字， 防止子类重写模板方法.</li></ol></li> <li><ol start="6"><li>模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤 ，这一 系列的步骤基本相同，但其个别步骤在实现时 可能不同，通常考虑用模板方法模 式来处理</li></ol></li></ul> <h3 id="_3-13、命令模式"><a href="#_3-13、命令模式" class="header-anchor">#</a> 3.13、命令模式</h3> <blockquote><p><strong>命令模式基本介绍</strong></p></blockquote> <ul><li><ol><li>命令模式（Command Pattern）：在软件设计中，我们经常需要 向某些对象发送请求，但是并不知道请求的接收者是谁，也不知 道被请求的操作是哪个， 我们只需在程序运行时指定具体的请求接收者即可，此时，可以 使用命令模式来进行设计</li></ol></li> <li><ol start="2"><li>命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让 对象之间的调用关系更加灵活，实现解耦。</li></ol></li> <li><ol start="3"><li>在命名模式中，会将一个请求封装为一个对象，以便使用不同参 数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。</li></ol></li> <li><ol start="4"><li>通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色： 将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将 军和士兵)。 Invoker是调用者（将军），Receiver是被调用者（士兵）， MyCommand是命令，实现了Command接口，持有接收对象</li></ol></li></ul> <blockquote><p><strong>命令模式的原理类图</strong></p></blockquote> <p>对原理类图的说明-即(命名模式的角色及职责)</p> <ol><li>Invoker 是调用者角色</li></ol> <ul><li><ol start="2"><li>Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类</li></ol></li></ul> <ol start="3"><li><p>Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作</p></li> <li><p>ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute</p></li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130133.png" alt="image-20200513202404406"></p> <blockquote><p><strong>命令模式在Spring框架JdbcTemplate应用的源码分析</strong></p></blockquote> <ol><li><p>Spring框架的JdbcTemplate就使用到了命令模式</p></li> <li><p>代码分析</p></li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130135.png" alt="image-20200513202435249"></p> <ol start="3"><li>模式角色分析说明</li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130138.png" alt="image-20200513202452595"></p> <blockquote><p><strong>命令模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要 调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对 象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：” 请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到 了纽带桥梁的作用。</li></ol></li> <li><ol start="2"><li>容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令</li></ol></li> <li><ol start="3"><li>容易实现对请求的撤销和重做</li></ol></li> <li><ol start="4"><li>命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这 点在在使用的时候要注意</li></ol></li> <li><ol start="5"><li>空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没 有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。</li></ol></li> <li><ol start="6"><li>命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD（DOS命令） 订单的撤销/恢复、触发-反馈机制</li></ol></li></ul> <h3 id="_3-14、访问者模式"><a href="#_3-14、访问者模式" class="header-anchor">#</a> 3.14、访问者模式</h3> <blockquote><p><strong>访问者模式基本介绍</strong></p></blockquote> <ul><li><ol><li>访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作， 它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</li></ol></li> <li><ol start="2"><li>主要将数据结构与数据操作分离，解决 数据结构和操作耦合性问题</li></ol></li> <li><ol start="3"><li>访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者 的接口</li></ol></li> <li><ol start="4"><li>访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作 (这些操作彼此没有关联)，同时需要避免让这些操作&quot;污染&quot;这些对象的类，可以 选用访问者模式解决</li></ol></li></ul> <blockquote><p><strong>访问者模式的原理类图</strong></p></blockquote> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130141.png" alt="image-20200513202612651"></p> <p><strong>对原理类图的说明即(访问者模式的角色及职责)</strong></p> <ul><li><ol><li>Visitor 是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作</li></ol></li> <li><ol start="2"><li>ConcreteVisitor ：是一个具体的访问值 实现每个有Visitor 声明的操作，是每个操作实现的部分.</li></ol></li> <li><ol start="3"><li>ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素</li></ol></li> <li><ol start="4"><li>Element 定义一个accept 方法，接收一个访问者对象</li></ol></li> <li><ol start="5"><li>ConcreteElement 为具体元素，实现了accept 方法</li></ol></li></ul> <blockquote><p><strong>访问者模式的注意事项和细节</strong></p></blockquote> <p><strong>优点</strong></p> <ul><li><ol><li>访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高</li></ol></li> <li><ol start="2"><li>访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据 结构相对稳定的系统</li></ol></li></ul> <p><strong>缺点</strong></p> <ul><li><ol><li>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米 特法则所不建议的, 这样造成了具体元素变更比较困难</li></ol></li> <li><ol start="2"><li>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li></ol></li> <li><ol start="3"><li>因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问 者模式就是比较合适的.</li></ol></li></ul> <h3 id="_3-15、迭代器模式"><a href="#_3-15、迭代器模式" class="header-anchor">#</a> 3.15、迭代器模式</h3> <blockquote><p><strong>迭代器模式基本介绍</strong></p></blockquote> <ul><li><ol><li>迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式</li></ol></li> <li><ol start="2"><li>如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类， 或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历 方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</li></ol></li> <li><ol start="3"><li>迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素， 不需要知道集合对象的底层表示，即：不暴露其内部的结构。</li></ol></li></ul> <blockquote><p><strong>迭代器模式的原理类图</strong></p></blockquote> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130144.png" alt="image-20200513202701310"></p> <blockquote><p><strong>对原理类图的说明-即(迭代器模式的角色及职责)</strong></p></blockquote> <ul><li><ol><li>Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove</li></ol></li> <li><ol start="2"><li>ConcreteIterator : 具体的迭代器类，管理迭代</li></ol></li> <li><ol start="3"><li>Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦</li></ol></li></ul> <blockquote><p><strong>迭代器模式在JDK-ArrayList集合应用的源码分析</strong></p></blockquote> <ol><li><p>JDK的ArrayList 集合中就使用了迭代器模式</p></li> <li><p>代码分析+类图+说明</p></li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130147.png" alt="image-20200513202724602"></p> <ol start="3"><li>角色分析说明 - 内部类Itr 充当具体实现迭代器Iterator 的类， 作为ArrayList 内部类 - List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象 - ArrayList 是实现聚合接口List 的子类，实现了iterator() - Iterator 接口系统提供 - 迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题</li></ol> <blockquote><p><strong>迭代器模式的注意事项和细节</strong></p></blockquote> <p><strong>优点</strong></p> <ul><li><ol><li>提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以 遍历对象了。</li></ol></li> <li><ol start="2"><li>隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚 合的具体组成。</li></ol></li> <li><ol start="3"><li>提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任 原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集 合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变 的话，只影响到了迭代器。</li></ol></li> <li><ol start="4"><li>当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式</li></ol></li></ul> <p><strong>缺点</strong></p> <ul><li>每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类</li></ul> <h3 id="_3-16、观察者模式"><a href="#_3-16、观察者模式" class="header-anchor">#</a> 3.16、观察者模式</h3> <blockquote><p><strong>观察者模式原理</strong></p></blockquote> <p>观察者模式类似订牛奶业务</p> <ol><li><p>奶站/气象局：Subject</p></li> <li><p>用户/第三方网站：Observer
Subject：登记注册、移除和通知</p></li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135052.png" alt="image-20200514135044858"></p> <ol><li><p>registerObserver 注册</p></li> <li><p>removeObserver 移除</p></li> <li><p>notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用 户来取，也可能是实施推送，看具体需求定</p></li></ol> <p>Observer：接收输入</p> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135723.png" alt="image-20200514135117776"></p> <p>观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject， 依赖的对象为Observer，Subject通知Observer变化,比如这里的奶站是 Subject，是1的一方。用户时Observer，是多的一方。</p> <blockquote><p><strong>观察者模式的好处</strong></p></blockquote> <ol><li><p>观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除 和通知。</p></li> <li><p>这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核 心类WeatherData不会修改代码，遵守了ocp原则。</p></li></ol> <blockquote><p><strong>观察者模式在Jdk应用的源码分析</strong></p></blockquote> <ol><li><p>Jdk的Observable类就使用了观察者模式</p></li> <li><p>代码分析+模式角色分析</p></li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135708.png" alt="image-20200514135205236"></p> <ol start="3"><li>模式角色分析 - Observable  的作用和地位等价于 我们前面讲过Subject - Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理Observer 的方法 add.. delete .. notify... - Observer 的作用和地位等价于我们前面讲过的 Observer, 有update - Observable 和 Observer 的使用方法和前面讲过的一样，只是Observable 是 类，通过继承来实现观察者模式</li></ol> <h3 id="_3-17、中介者模式"><a href="#_3-17、中介者模式" class="header-anchor">#</a> 3.17、中介者模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ul><li><ol><li>中介者模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。 中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立 地改变它们之间的交互</li></ol></li> <li><ol start="2"><li>中介者模式属于行为型模式，使代码易于维护</li></ol></li> <li><ol start="3"><li>比如MVC模式，C（Controller控制器）是M（Model模型）和V（View视图）的中 介者，在前后端交互时起到了中间人的作用</li></ol></li></ul> <blockquote><p><strong>中介者模式的原理类图</strong></p></blockquote> <p><strong>对原理类图的说明-即(中介者模式的角色及职责)</strong></p> <ul><li><ol><li>Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口</li></ol></li> <li><ol start="2"><li>Colleague 是抽象同事类</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135713.png" alt="image-20200514135251109"></p> <blockquote><p><strong>中介者模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构， 进行解耦</li></ol></li> <li><ol start="2"><li>减少类间依赖，降低了耦合，符合迪米特原则</li></ol></li> <li><ol start="3"><li>中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li></ol></li> <li><ol start="4"><li>如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意</li></ol></li></ul> <h3 id="_3-18、备忘录模式"><a href="#_3-18、备忘录模式" class="header-anchor">#</a> 3.18、备忘录模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ul><li><ol><li>备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内 部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保 存的状态</li></ol></li> <li><ol start="2"><li>可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情， 或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录 模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某 些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作</li></ol></li> <li><ol start="3"><li>备忘录模式属于行为型模式</li></ol></li></ul> <blockquote><p><strong>备忘录模式的原理类图</strong></p></blockquote> <p>对原理类图的说明-即 (备忘录模式的角色及职责)</p> <ol><li><p>originator : 对象(需要保存 状态的对象)</p></li> <li><p>Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态</p></li> <li><p>Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效 率</p></li> <li><p>说明：如果希望保存多个originator对象的不同时间的状态，也可以，只需要 要 HashMap &lt;String, 集合&gt;</p></li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135715.png" alt="image-20200514135343721"></p> <p>针对前面的备忘录模式原理结构图，我们使用代码来说明一把，注意体会体现出 Caretaker 可以保存多个备忘录对象, 方便管理，提高效率。</p> <blockquote><p><strong>备忘录模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史 的状态</li></ol></li> <li><ol start="2"><li>实现了信息的封装，使得用户不需要关心状态的保存细节</li></ol></li> <li><ol start="3"><li>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定 的内存, 这个需要注意</li></ol></li> <li><ol start="4"><li>适用的应用场景：1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理</li></ol></li> <li><ol start="5"><li>为了节约内存，备忘录模式可以和原型模式配合使用</li></ol></li></ul> <h3 id="_3-19、解释器模式"><a href="#_3-19、解释器模式" class="header-anchor">#</a> 3.19、解释器模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ul><li><ol><li>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法 单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这 里的词法分析器和语法分析器都可以看做是解释器</li></ol></li> <li><ol start="2"><li>解释器模式（Interpreter Pattern）：是指给定一个语言(表达式)，定义它的文法 的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子(表达式)</li></ol></li> <li><ol start="3"><li>应用场景 • 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树 • 一些重复出现的问题可以用一种简单的语言来表达 • 一个简单语法需要解释的场景</li></ol></li> <li><ol start="4"><li>这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等</li></ol></li></ul> <blockquote><p><strong>解释器模式的原理类图</strong></p></blockquote> <p><strong>对原理类图的说明-即(解释器模式的角色及职责)</strong></p> <ul><li><ol><li>Context: 是环境角色,含有解释器之外的全局信息.</li></ol></li> <li><ol start="2"><li>AbstractExpression: 抽象表达式， 声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点所 共享</li></ol></li> <li><ol start="3"><li>TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作</li></ol></li> <li><ol start="4"><li>NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作.</li></ol></li> <li><ol start="5"><li>说明： 输入Context he TerminalExpression 信息通过Client 输入即可</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200515132105.png" alt="image-20200515132010576"></p> <blockquote><p><strong>解释器模式在Spring框架应用的源码剖析</strong></p></blockquote> <ol><li><p>Spring框架中 SpelExpressionParser就使用到解释器模式</p></li> <li><p>代码分析+Debug源码</p></li></ol> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200515132057.png" alt="image-20200515132041571"></p> <ol start="3"><li>说明 - Expression 接口 表达式接口 - 下面有不同的实现类，比如SpelExpression, 或者CompositeStringExpression。 - 使用时候，根据你创建的不同的Parser 对象，返回不同的 Expression 对象 public Expression parseExpression(String expressionString, ParserContext context) throws ParseException { if (context == null) { context = NON_TEMPLATE_PARSER_CONTEXT; }
if (context.isTemplate()) { return parseTemplate(expressionString, context); //返回的就是 CompositeStringExpression } else { return doParseExpression(expressionString, context); //返回的就是SpelExpression } } - 使用得当 Expression对象，调用getValue 解释执行 表达式，最后得到结果</li></ol> <blockquote><p><strong>解释器模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以 考虑使用解释器模式，让程序具有良好的扩展性</li></ol></li> <li><ol start="2"><li>应用场景：编译器、运算表达式计算、正则表达式、机器人等</li></ol></li> <li><ol start="3"><li>使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用 方法，将会导致调试非常复杂、效率可能降低.</li></ol></li></ul> <h3 id="_3-20、状态模式"><a href="#_3-20、状态模式" class="header-anchor">#</a> 3.20、状态模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ul><li><ol><li>状态模式（State Pattern）：它主要用来解决对象在多种状态转换时，需要对外 输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换</li></ol></li> <li><ol start="2"><li>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了 其类</li></ol></li></ul> <blockquote><p><strong>状态模式的原理类图</strong></p></blockquote> <p><strong>对原理类图的说明-即(状态模式的角色及职责)</strong></p> <ul><li><ol><li>Context 类为环境角色, 用于维护State实例,这个实例定义当前状态</li></ol></li> <li><ol start="2"><li>State 是抽象状态角色,定义一个接口封装与Context 的一个特点接口相关行为</li></ol></li> <li><ol start="3"><li>ConcreteState 具体的状态角色，每个子类实现一个与Context 的一个状态相关行为</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200515132208.png" alt="image-20200515132205047"></p> <blockquote><p><strong>状态模式在实际项目-借贷平台 源码剖析</strong></p></blockquote> <ul><li><ol><li>借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的 状态, 项目中的这个模块实现就会使用到状态模式</li></ol></li> <li><ol start="2"><li>通常通过if/else判断订单的状态，从而实现不同的逻辑，伪代码如下</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200515132329.png" alt="image-20200515132248223"></p> <blockquote><p><strong>状态模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中</li></ol></li> <li><ol start="2"><li>方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一 个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句， 而且容易出错</li></ol></li> <li><ol start="3"><li>符合“开闭原则”。容易增删状态</li></ol></li> <li><ol start="4"><li>会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维 护难度</li></ol></li> <li><ol start="5"><li>应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状 态要求有不同的行为的时候，可以考虑使用状态模式</li></ol></li></ul> <h3 id="_3-21、策略模式"><a href="#_3-21、策略模式" class="header-anchor">#</a> 3.21、策略模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ul><li><ol><li>策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以 互相替换，此模式让算法的变化独立于使用算法的客户</li></ol></li> <li><ol start="2"><li>这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来； 第二、针对接口编程而不是具体类（定义了策略接口）；第三、多用组合/聚合， 少用继承（客户通过组合方式使用策略）。</li></ol></li></ul> <blockquote><p><strong>策略模式的原理类图</strong></p></blockquote> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200515132326.png" alt="image-20200515132314805"></p> <blockquote><p><strong>策略模式在JDK-Arrays 应用的源码分析</strong></p></blockquote> <ul><li><ol><li>JDK的 Arrays 的Comparator就使用了策略模式</li></ol></li> <li><ol start="2"><li>代码分析+Debug源码+模式角色分析</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200515132403.png" alt="image-20200515132402738"></p> <blockquote><p><strong>策略模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>策略模式的关键是：分析项目中变化部分与不变部分</li></ol></li> <li><ol start="2"><li>策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的 继承。更有弹性</li></ol></li> <li><ol start="3"><li>体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只 要添加一种策略（或者行为）即可，避免了使用多重转移语句（if..else if..else）</li></ol></li> <li><ol start="4"><li>提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy类中使得 你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展</li></ol></li> <li><ol start="5"><li>需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</li></ol></li></ul> <h3 id="_3-22、职责链模式"><a href="#_3-22、职责链模式" class="header-anchor">#</a> 3.22、职责链模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ul><li><ol><li>职责链模式（Chain of Responsibility Pattern）, 又叫 责任链模式，为请求创建了一个接收者 对象的链(简单示意图)。这种模式对请求的 发送者和接收者进行解耦。</li></ol></li> <li><ol start="2"><li>职责链模式通常每个接收者都包含对另一个接 收者的引用。如果一个对象不能处理该请求， 那么它会把相同的请求传给下一个接收者，依 此类推。</li></ol></li> <li><ol start="3"><li>这种类型的设计模式属于行为型模式</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200515132432.png" alt="image-20200515132431296"></p> <blockquote><p><strong>职责链模式的原理类图</strong></p></blockquote> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200515132857.png" alt="image-20200515132450010"></p> <blockquote><p><strong>对原理类图的说明-即(职责链模式的角色及职责)</strong></p></blockquote> <ul><li><ol><li>Handler : 抽象的处理者, 定义了一个处理请求的接口, 同时含义另外Handler</li></ol></li> <li><ol start="2"><li>ConcreteHandlerA , B 是具体的处理者, 处理它自己负责的请求， 可以访问它的后继者(即下一个处 理者), 如果可以处理当前请求，则处理，否则就将该请求交个 后继者去处理，从而形成一个职责链</li></ol></li> <li><ol start="3"><li>Request ， 含义很多属性，表示一个请求</li></ol></li></ul> <blockquote><p><strong>职责链模式在SpringMVC框架应用的源码分析</strong></p></blockquote> <ul><li><ol><li>SpringMVC-HandlerExecutionChain 类就使用到职责链模式</li></ol></li> <li><ol start="2"><li>SpringMVC请求流程简图</li></ol></li> <li><ol start="3"><li>说明 - springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等 - 在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式 - HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不 处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责 链本身与处理逻辑之间的耦合,规范了处理流程 - HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应 的拦截器.</li></ol></li></ul> <p><img src="https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200515132652.png" alt="image-20200515132510118"></p> <blockquote><p><strong>职责链模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>将请求和处理分开，实现解耦，提高系统的灵活性</li></ol></li> <li><ol start="2"><li>简化了对象，使对象不需要知道链的结构</li></ol></li> <li><ol start="3"><li>性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般 通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值， 超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li></ol></li> <li><ol start="4"><li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li></ol></li> <li><ol start="5"><li>最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪 等审批流程、Java Web中Tomcat对Encoding的处理、拦截器</li></ol></li></ul></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">5/16/2020, 2:29:26 PM</span></div></footer> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-44bd5a18 data-v-44bd5a18><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-44bd5a18><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-44bd5a18></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-44bd5a18></path></svg></div></div></div>
    <script src="/assets/js/app.99643522.js" defer></script><script src="/assets/js/3.6a376a2c.js" defer></script><script src="/assets/js/1.3b62a509.js" defer></script><script src="/assets/js/18.ab53c384.js" defer></script>
  </body>
</html>
