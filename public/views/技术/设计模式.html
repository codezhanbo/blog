<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>设计模式详解 | 麋鹿的博客</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="读书破万卷，下笔如有神">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/assets/css/0.styles.9c21bd57.css" as="style"><link rel="preload" href="/assets/js/app.dc196ffd.js" as="script"><link rel="preload" href="/assets/js/3.b0f95413.js" as="script"><link rel="preload" href="/assets/js/1.a59b7061.js" as="script"><link rel="preload" href="/assets/js/17.dcf07e59.js" as="script"><link rel="prefetch" href="/assets/js/10.d20efea8.js"><link rel="prefetch" href="/assets/js/11.5a9e4563.js"><link rel="prefetch" href="/assets/js/12.706a06b8.js"><link rel="prefetch" href="/assets/js/13.1b49b117.js"><link rel="prefetch" href="/assets/js/14.d02dfad0.js"><link rel="prefetch" href="/assets/js/15.80183f7d.js"><link rel="prefetch" href="/assets/js/16.464ffc1b.js"><link rel="prefetch" href="/assets/js/18.3a2a8318.js"><link rel="prefetch" href="/assets/js/4.73213e4f.js"><link rel="prefetch" href="/assets/js/5.001187f8.js"><link rel="prefetch" href="/assets/js/6.5e86b234.js"><link rel="prefetch" href="/assets/js/7.df04ee3d.js"><link rel="prefetch" href="/assets/js/8.9eb7627a.js"><link rel="prefetch" href="/assets/js/9.c1b6b22b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9c21bd57.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-19557b78><div data-v-19557b78><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-19557b78 data-v-19557b78><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-19557b78 data-v-19557b78><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>麋鹿的博客</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>麋鹿</span>
            
          <span data-v-64685f0e>2019 - </span>
          2020
        </a></span></div></div> <div class="hide" data-v-19557b78><header class="navbar" data-v-19557b78><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="麋鹿的博客" class="logo"> <span class="site-name">麋鹿的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/categories/资料/" class="nav-link"><i class="iconfont undefined"></i>
  资料
</a></li><li class="dropdown-item"><!----> <a href="/categories/技术类/" class="nav-link"><i class="iconfont undefined"></i>
  技术类
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/zhanbo136" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-19557b78></div> <aside class="sidebar" data-v-19557b78><div class="personal-info-wrapper" data-v-b038cec6><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-b038cec6> <h3 class="name" data-v-b038cec6>
    麋鹿
  </h3> <div class="num" data-v-b038cec6><div data-v-b038cec6><h3 data-v-b038cec6>6</h3> <h6 data-v-b038cec6>Article</h6></div> <div data-v-b038cec6><h3 data-v-b038cec6>4</h3> <h6 data-v-b038cec6>Tag</h6></div></div> <hr data-v-b038cec6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/categories/资料/" class="nav-link"><i class="iconfont undefined"></i>
  资料
</a></li><li class="dropdown-item"><!----> <a href="/categories/技术类/" class="nav-link"><i class="iconfont undefined"></i>
  技术类
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/zhanbo136" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>设计模式详解</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_1、设计模式七大原则" class="sidebar-link">1、设计模式七大原则</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_2、uml类图" class="sidebar-link">2、UML类图</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_2-1类之间的关系：" class="sidebar-link">2.1类之间的关系：</a></li></ul></li><li><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3、-设计模式类型" class="sidebar-link">3、 设计模式类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-1、单例模式" class="sidebar-link">3.1、单例模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-2、工厂模式" class="sidebar-link">3.2、工厂模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-3、原型模式" class="sidebar-link">3.3、原型模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-4、建造者模式" class="sidebar-link">3.4、建造者模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-5、适配器模式" class="sidebar-link">3.5、适配器模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-6、桥接模式" class="sidebar-link">3.6、桥接模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-7、装饰者设计模式" class="sidebar-link">3.7、装饰者设计模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-8、组合模式" class="sidebar-link">3.8、组合模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-9、外观模式" class="sidebar-link">3.9、外观模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-10、享元模式" class="sidebar-link">3.10、享元模式</a></li><li class="sidebar-sub-header"><a href="/views/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#_3-11、代理模式" class="sidebar-link">3.11、代理模式</a></li></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-19557b78><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>设计模式详解</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>麋鹿</span>
            
          <span data-v-64685f0e>2019 - </span>
          2020
        </a></span></div></div> <div data-v-19557b78><main class="page"><div class="page-title" style="display:none;"><h1>设计模式详解</h1> <hr> <div data-v-484a899e><i class="iconfont reco-account" data-v-484a899e><span data-v-484a899e>麋鹿</span></i> <i class="iconfont reco-date" data-v-484a899e><span data-v-484a899e>2020-05-01</span></i> <!----> <i class="iconfont reco-tag tags" data-v-484a899e><span class="tag-item" data-v-484a899e>
      设计模式
    </span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h1> <h2 id="_1、设计模式七大原则"><a href="#_1、设计模式七大原则" class="header-anchor">#</a> 1、设计模式七大原则</h2> <ul><li><p>单一职责原则</p></li> <li><p>接口隔离原则</p></li> <li><p>依赖倒转(倒置)原则</p></li> <li><p>里氏替换原则</p></li> <li><p>开闭原则</p></li> <li><p>迪米特法则</p></li> <li><p>合成复用原则</p></li></ul> <h2 id="_2、uml类图"><a href="#_2、uml类图" class="header-anchor">#</a> 2、UML类图</h2> <ul><li>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统 分析和设计的语言工具，它用于帮助软 件开发人员进行思考和记录思路的结果</li> <li>UML本身是一套符号的规定，就像数学 符号和化学符号一样，这些符号用于描 述软件模型中的各个元素和他们之间的 关系，比如类、接口、实现、泛化、依 赖、组合、聚合等，如右图: <img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200417104235195.png" alt="image-20200417104235195"></li> <li>使用UML来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模</li></ul> <h3 id="_2-1类之间的关系："><a href="#_2-1类之间的关系：" class="header-anchor">#</a> 2.1类之间的关系：</h3> <blockquote><p>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系</p></blockquote> <ul><li>依赖</li> <li>泛化（继承）</li> <li>实现</li> <li>关联</li> <li>聚合</li> <li>组合</li></ul> <h2 id="_3、-设计模式类型"><a href="#_3、-设计模式类型" class="header-anchor">#</a> 3、 设计模式类型</h2> <p>设计模式分为三种类型，共23种</p> <ol><li><p>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。</p></li> <li><p>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享 元模式、代理模式。</p></li> <li><p>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模 式、策略模式、职责链模式(责任链模式)。</p></li></ol> <h3 id="_3-1、单例模式"><a href="#_3-1、单例模式" class="header-anchor">#</a> 3.1、单例模式</h3> <ul><li>饿汉式(静态常量)</li> <li>饿汉式（静态代码块）</li> <li>懒汉式(线程不安全)</li> <li>懒汉式(线程安全，同步方法)</li> <li>懒汉式(线程安全，同步代码块)</li> <li>双重检查</li> <li>静态内部类</li> <li>枚举</li></ul> <blockquote><p><strong>饿汉式（静态常量）</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。</li> <li>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费</li> <li>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化instance就没有达到lazy loading的效果</li> <li>结论：这种单例模式可用，可能造成内存浪费</li></ul> <blockquote><p><strong>饿汉式（静态代码块）</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li><ol><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块 中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优 缺点和上面是一样的。</li></ol></li> <li><ol start="2"><li>结论：这种单例模式可用，但是可能造成内存浪费</li></ol></li></ul> <blockquote><p><strong>懒汉式(线程不安全)</strong></p></blockquote> <p><strong>优缺点说明</strong>：</p> <ul><li><ol><li>起到了Lazy Loading的效果，但是只能在单线程下使用。</li></ol></li> <li><ol start="2"><li>如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式 3) 结论：在实际开发中，不要使用这种方式</li></ol></li></ul> <blockquote><p><strong>懒汉式(线程安全，同步方法)</strong></p></blockquote> <p><strong>优缺点说明</strong>：</p> <ul><li><ol><li>解决了线程不安全问题</li></ol></li> <li><ol start="2"><li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低 3) 结论：在实际开发中，不推荐使用这种方式</li></ol></li></ul> <blockquote><p><strong>双重检查</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li><ol><li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次if (singleton == null)检查，这样就可以保证线程安全了。</li></ol></li> <li><ol start="2"><li>这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， 直接return实例化对象，也避免的反复进行方法同步.</li></ol></li> <li><ol start="3"><li>线程安全；延迟加载；效率较高</li></ol></li> <li><ol start="4"><li>结论：在实际开发中，推荐使用这种单例设计模</li></ol></li></ul> <blockquote><p><strong>静态内部类</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li><ol><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li></ol></li> <li><ol start="2"><li>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 实例化。</li></ol></li> <li><ol start="3"><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li></ol></li> <li><ol start="4"><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li></ol></li> <li><ol start="5"><li>结论：推荐使用.</li></ol></li></ul> <blockquote><p><strong>枚举</strong></p></blockquote> <p><strong>优缺点说明（推荐）</strong>：</p> <ul><li><ol><li>这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 且还能防止反序列化重新创建新的对象。</li></ol></li> <li><ol start="2"><li>这种方式是Effective Java作者Josh Bloch 提倡的方式</li></ol></li> <li><ol start="3"><li>结论：推荐使用</li></ol></li></ul> <h3 id="_3-2、工厂模式"><a href="#_3-2、工厂模式" class="header-anchor">#</a> 3.2、工厂模式</h3> <ul><li>简单工厂模式</li> <li>工厂方法模式</li> <li>抽象工厂模式</li></ul> <blockquote><p><strong>基本介绍</strong>：</p></blockquote> <ul><li><ol><li>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一 个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族 中最简单实用的模式</li></ol></li> <li><ol start="2"><li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行 为(代码)</li></ol></li> <li><ol start="3"><li>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会 使用到工厂模式</li></ol></li></ul> <blockquote><p><strong>工厂方法模式</strong></p></blockquote> <p>工厂方法模式介绍</p> <ul><li>工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点 餐子类中具体实现。</li> <li>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方 法模式将对象的实例化推迟到子类。</li></ul> <blockquote><p><strong>抽象工厂模式</strong></p></blockquote> <ul><li><ol><li>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需 指明具体的类</li></ol></li> <li><ol start="2"><li>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li></ol></li> <li><ol start="3"><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</li></ol></li> <li><ol start="4"><li>将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以 根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇， 更利于代码的维护和扩展。</li></ol></li></ul> <p><strong>工厂模式小结</strong>：</p> <ul><li><ol><li>工厂模式的意义 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的 依赖关系的解耦。从而提高项目的扩展和维护性。</li></ol></li> <li><ol start="2"><li>三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)</li></ol></li> <li><ol start="3"><li>设计模式的依赖抽象原</li></ol></li></ul> <h3 id="_3-3、原型模式"><a href="#_3-3、原型模式" class="header-anchor">#</a> 3.3、原型模式</h3> <blockquote><p><strong>基本介绍</strong>：</p></blockquote> <ul><li><ol><li>原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷 贝这些原型，创建新的对象</li></ol></li> <li><ol start="2"><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节</li></ol></li> <li><ol start="3"><li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建 的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()</li></ol></li> <li><ol start="4"><li>形象的理解：孙大圣拔出猴毛， 变出其它孙大圣</li></ol></li></ul> <blockquote><p><strong>原型模式原理结构图-uml类图：</strong></p></blockquote> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200417221010897.png" alt="image-20200417221010897"></p> <blockquote><p><strong>原理结构图说明</strong> ：</p></blockquote> <ul><li><ol><li>Prototype : 原型类，声明一个克隆自己的接口</li></ol></li> <li><ol start="2"><li>ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作</li></ol></li> <li><ol start="3"><li>Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)</li></ol></li></ul> <p><strong>深入讨论-浅拷贝和深拷贝</strong></p> <blockquote><p><strong>浅拷贝的介绍：</strong></p></blockquote> <ul><li><ol><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将 该属性值复制一份给新的对象。</li></ol></li> <li><ol start="2"><li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类 的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内 存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个 实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成 员变量值</li></ol></li> <li><ol start="3"><li>前面我们克隆羊就是浅拷贝</li></ol></li> <li><ol start="4"><li>浅拷贝是使用默认的 clone()方法来实现 sheep = (Sheep) super.clone();</li></ol></li></ul> <blockquote><p><strong>深拷贝基本介绍：</strong></p></blockquote> <ul><li><ol><li>复制对象的所有基本数据类型的成员变量值</li></ol></li> <li><ol start="2"><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变 量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对 整个对象进行拷贝。</li></ol></li> <li><ol start="3"><li>深拷贝实现方式1：重写clone方法来实现深拷贝</li></ol></li> <li><ol start="4"><li>深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)</li></ol></li></ul> <blockquote><p><strong>原型模式的注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提 高效率</li></ol></li> <li><ol start="2"><li>不用重新初始化对象，而是动态地获得对象运行时的状态</li></ol></li> <li><ol start="3"><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化， 无需修改代码</li></ol></li> <li><ol start="4"><li>在实现深克隆的时候可能需要比较复杂的代码</li></ol></li> <li><ol start="5"><li>缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有 的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意.</li></ol></li></ul> <h3 id="_3-4、建造者模式"><a href="#_3-4、建造者模式" class="header-anchor">#</a> 3.4、建造者模式</h3> <blockquote><p><strong>基本介绍：</strong></p></blockquote> <ul><li><ol><li>建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以 将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方 法可以构造出不同表现（属性）的对象。</li></ol></li> <li><ol start="2"><li>建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象 的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</li></ol></li></ul> <blockquote><p><strong>建造者模式的四个角色：</strong></p></blockquote> <ul><li><ol><li>Product（产品角色）： 一个具体的产品对象。</li></ol></li> <li><ol start="2"><li>Builder（抽象建造者）： 创建一个Product对象的各个部件指定的 接口/抽象类。</li></ol></li> <li><ol start="3"><li>ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。</li></ol></li> <li><ol start="4"><li>Director（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个 复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是： 负责控制产品对象的生产过程</li></ol></li></ul> <blockquote><p><strong>建造者模式原理类图</strong>：</p></blockquote> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200417221339283.png" alt="image-20200417221339283"></p> <blockquote><p><strong>建造者模式的注意事项和细节</strong>：</p></blockquote> <ul><li><ol><li>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解 耦，使得相同的创建过程可以创建不同的产品对象</li></ol></li> <li><ol start="2"><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替 换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同 的产品对象</li></ol></li> <li><ol start="3"><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法 中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</li></ol></li> <li><ol start="4"><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程， 系统扩展方便，符合 “开闭原则”</li></ol></li></ul> <h3 id="_3-5、适配器模式"><a href="#_3-5、适配器模式" class="header-anchor">#</a> 3.5、适配器模式</h3> <p><strong>基本介绍</strong></p> <ul><li><ol><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表 示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同 工作。其别名为包装器(Wrapper)</li></ol></li> <li><ol start="2"><li>适配器模式属于结构型模式</li></ol></li> <li><ol start="3"><li>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</li></ol></li></ul> <blockquote><p><strong>适配器模式工作原理：</strong></p></blockquote> <ul><li><ol><li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼 容</li></ol></li> <li><ol start="2"><li>从用户的角度看不到被适配者，是解耦的</li></ol></li> <li><ol start="3"><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口 方法</li></ol></li> <li><ol start="4"><li>用户收到反馈结果，感觉只是和目标接口交互，如图</li></ol></li></ul> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200418094510964.png" alt="image-20200418094510964"></p> <p><strong>类适配器模式</strong></p> <blockquote><p><strong>类适配器模式介绍：</strong></p></blockquote> <ul><li>Adapter类，通过继承 src类，实现 dst 类接口，完成src-&gt;dst的适配。</li></ul> <blockquote><p><strong>类适配器模式注意事项和细节</strong></p></blockquote> <ul><li><ol><li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要 求dst必须是接口，有一定局限性;</li></ol></li> <li><ol start="2"><li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</li></ol></li> <li><ol start="3"><li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵 活性增强了。</li></ol></li></ul> <blockquote><p><strong>类适配器模式注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要 求dst必须是接口，有一定局限性;</li></ol></li> <li><ol start="2"><li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本。</li></ol></li> <li><ol start="3"><li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵 活性增强了</li></ol></li></ul> <p><strong>对象适配器模式</strong></p> <blockquote><p><strong>对象适配器模式介绍</strong></p></blockquote> <ul><li><ol><li>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而 是持有src类的实例，以解决兼容性的问题。 即：持有 src类，实现 dst 类接口， 完成src-&gt;dst的适配</li></ol></li> <li><ol start="2"><li>根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。</li></ol></li> <li><ol start="3"><li>对象适配器模式是适配器模式常用的一种</li></ol></li></ul> <blockquote><p><strong>对象适配器模式注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承src的 局限性问题，也不再要求dst必须是接口。</li></ol></li> <li><ol start="2"><li>使用成本更低，更灵活。</li></ol></li></ul> <blockquote><p><strong>接口适配器模式介绍：</strong></p></blockquote> <ul><li><ol><li>一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。</li></ol></li> <li><ol start="2"><li>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接 口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆 盖父类的某些方法来实现需求</li></ol></li> <li><ol start="3"><li>适用于一个接口不想使用其所有的方法的情况。</li></ol></li></ul> <blockquote><p><strong>适配器模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来 命名的。</li></ol></li> <li><ol start="2"><li>类适配器：以类给到，在Adapter里，就是将src当做类，继承 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现</li></ol></li> <li><ol start="3"><li>Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</li></ol></li> <li><ol start="4"><li>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</li></ol></li></ul> <h3 id="_3-6、桥接模式"><a href="#_3-6、桥接模式" class="header-anchor">#</a> 3.6、桥接模式</h3> <blockquote><p><strong>基本介绍：</strong></p></blockquote> <ul><li><ol><li>桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层 次可以独立改变。</li></ol></li> <li><ol start="2"><li>是一种结构型设计模式</li></ol></li> <li><ol start="3"><li>Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同 的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现 (Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能 扩展</li></ol></li></ul> <blockquote><p><strong>桥接模式原理类图：</strong></p></blockquote> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200418104355271.png" alt="image-20200418104355271"></p> <blockquote><p><strong>原理类图说明：</strong></p></blockquote> <ul><li><ol><li>Client类：桥接模式的调用者</li></ol></li> <li><ol start="2"><li>抽象类(Abstraction) :维护了 Implementor / 即它的实现类ConcreteImplementorA.., 二者是聚合关系, Abstraction 充当 桥接类</li></ol></li></ul> <blockquote><p><strong>桥接模式的注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实 现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li></ol></li> <li><ol start="2"><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部 分由具体业务来完成。</li></ol></li> <li><ol start="3"><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</li></ol></li> <li><ol start="4"><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层， 要求开发者针对抽象进行设计和编程 5) 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局 限性，即需要有这样的应用场景</li></ol></li></ul> <h3 id="_3-7、装饰者设计模式"><a href="#_3-7、装饰者设计模式" class="header-anchor">#</a> 3.7、装饰者设计模式</h3> <h3 id="_3-8、组合模式"><a href="#_3-8、组合模式" class="header-anchor">#</a> 3.8、组合模式</h3> <blockquote><p>基本介绍：</p></blockquote> <ul><li><ol><li>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结 构，将对象组合成树状结构以表示“整体-部分”的层次关系。</li></ol></li> <li><ol start="2"><li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 3) 这种类型的设计模式属于结构型模式。 4) 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客 户以一致的方式处理个别对象以及组合对象理结构图的说明-即(组合模式的角色及职责)</li></ol></li></ul> <blockquote><p>组合模式的原理类图：</p></blockquote> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210536399.png" alt="image-20200510210536399"></p> <ul><li><ol><li>Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子 部件, Component 可以是抽象类或者接口</li></ol></li> <li><ol start="2"><li>Leaf : 在组合中表示叶子节点，叶子节点没有子节点</li></ol></li></ul> <p><strong>解决的问题</strong></p> <blockquote><p>组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而 我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑 它是节点还是叶子 2) 对应的示意图</p></blockquote> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210610447.png" alt="image-20200510210610447"></p> <blockquote><p><strong>组合模式在JDK集合的源码分析</strong></p></blockquote> <p><strong>组合模式在JDK集合的源码分析：</strong>
Java的集合类-HashMap就使用了组合模式 2) 代码分析+Debug 源码</p> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210709009.png" alt="image-20200510210709009"></p> <blockquote><p><strong>组合模式的注意事项和细节：</strong></p></blockquote> <ul><li><ol><li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子 的问题。</li></ol></li> <li><ol start="2"><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系， 客户端不用做出任何改动.</li></ol></li> <li><ol start="3"><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点 或者叶子从而创建出复杂的树形结构</li></ol></li> <li><ol start="4"><li>需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.</li></ol></li> <li><ol start="5"><li>要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性 都不一样，不适合使用组合模式</li></ol></li></ul> <h3 id="_3-9、外观模式"><a href="#_3-9、外观模式" class="header-anchor">#</a> 3.9、外观模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ol><li><p>外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供 一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加 容易使用</p></li> <li><p>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端 只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p></li></ol> <blockquote><p><strong>外观模式原理类图</strong></p></blockquote> <ul><li><ol><li>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当 子系统对象</li></ol></li> <li><ol start="2"><li>调用者(Client): 外观接口的调用者</li></ol></li> <li><ol start="3"><li>子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者</li></ol></li></ul> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210920073.png" alt="image-20200510210920073"></p> <blockquote><p><strong>外观模式在MyBatis框架应用的源码分析</strong></p></blockquote> <ol><li>MyBatis 中的Configuration 去创建MetaObject 对象使用到外观模式 2) 代码分析+Debug源码+示意图</li></ol> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210954986.png" alt="image-20200510210954986"></p> <blockquote><p><strong>外观模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复 杂性</li></ol></li> <li><ol start="2"><li>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</li></ol></li> <li><ol start="3"><li>通过合理的使用外观模式，可以帮我们更好的划分访问的层次</li></ol></li> <li><ol start="4"><li>当系统需要进行分层设计时，可以考虑使用Facade模式</li></ol></li> <li><ol start="5"><li>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时 可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 让新系统与Facade类交互，提高复用性</li></ol></li> <li><ol start="6"><li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。 要以让系统有层次，利于维护为目的</li></ol></li></ul> <h3 id="_3-10、享元模式"><a href="#_3-10、享元模式" class="header-anchor">#</a> 3.10、享元模式</h3> <blockquote><p><strong>基本介绍</strong></p></blockquote> <ul><li><ol><li>享元模式（Flyweight Pattern） 也叫 蝇量模式: 运 用共享技术有效地支持大量细粒度的对象</li></ol></li> <li><ol start="2"><li>常用于系统底层开发，解决系统的性能问题。像 数据库连接池，里面都是创建好的连接对象，在 这些连接对象中有我们需要的则直接拿来用，避 免重新创建，如果没有我们需要的，则创建一个</li></ol></li> <li><ol start="3"><li>享元模式能够解决重复对象的内存浪费的问题， 当系统中有大量相似对象，需要缓冲池时。不需 总是创建新对象，可以从缓冲池里拿。这样可以 降低系统内存，同时提高效率</li></ol></li> <li><ol start="4"><li>享元模式经典的应用场景就是池技术了，String常 量池、数据库连接池、缓冲池等等都是享元模式 的应用，享元模式是池技术的重要实现方式</li></ol></li></ul> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510221232579.png" alt="image-20200510221232579"></p> <blockquote><p><strong>享元模式的原理类图</strong></p></blockquote> <p>对原理图的说明-即(模式的角色及职责)</p> <ul><li><ol><li>FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现</li></ol></li> <li><ol start="2"><li>ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li></ol></li></ul> <p><img src="C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510221247213.png" alt="image-20200510221247213"></p> <p><strong>内部状态和外部状态</strong></p> <p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一 点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后， 落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p> <ul><li><ol><li>享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态 了，即将对象的信息分为两个部分：内部状态和外部状态</li></ol></li> <li><ol start="2"><li>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</li></ol></li> <li><ol start="3"><li>外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</li></ol></li> <li><ol start="4"><li>举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对 象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用 享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解 决了对象的开销问题</li></ol></li></ul> <blockquote><p><strong>享元模式在JDK-Interger的应用源码分析</strong></p></blockquote> <ul><li><ol><li>Integer中的享元模式</li></ol></li> <li><ol start="2"><li>代码分析+Debug源码+说明</li></ol></li></ul> <p><img src="hero.png" alt="image-20200510221328202"></p> <blockquote><p><strong>享元模式的注意事项和细节</strong></p></blockquote> <ul><li><ol><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li></ol></li> <li><ol start="2"><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时， 我们就可以考虑选用享元模式</li></ol></li> <li><ol start="3"><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap/HashTable存储</li></ol></li> <li><ol start="4"><li>享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</li></ol></li> <li><ol start="5"><li>享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有 固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的 地方.</li></ol></li> <li><ol start="6"><li>使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。</li></ol></li> <li><ol start="7"><li>享元模式经典的应用场景是需要缓冲池的场景，比如 String常量池、数据库连接池</li></ol></li></ul> <h3 id="_3-11、代理模式"><a href="#_3-11、代理模式" class="header-anchor">#</a> 3.11、代理模式</h3></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-44bd5a18 data-v-44bd5a18><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-44bd5a18><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-44bd5a18></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-44bd5a18></path></svg></div></div></div>
    <script src="/assets/js/app.dc196ffd.js" defer></script><script src="/assets/js/3.b0f95413.js" defer></script><script src="/assets/js/1.a59b7061.js" defer></script><script src="/assets/js/17.dcf07e59.js" defer></script>
  </body>
</html>
