(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{478:function(t,l,_){"use strict";_.r(l);var v=_(4),a=Object(v.a)({},(function(){var t=this,l=t.$createElement,_=t._self._c||l;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),_("h2",{attrs:{id:"_1、设计模式七大原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、设计模式七大原则"}},[t._v("#")]),t._v(" 1、设计模式七大原则")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("单一职责原则")])]),t._v(" "),_("li",[_("p",[t._v("接口隔离原则")])]),t._v(" "),_("li",[_("p",[t._v("依赖倒转(倒置)原则")])]),t._v(" "),_("li",[_("p",[t._v("里氏替换原则")])]),t._v(" "),_("li",[_("p",[t._v("开闭原则")])]),t._v(" "),_("li",[_("p",[t._v("迪米特法则")])]),t._v(" "),_("li",[_("p",[t._v("合成复用原则")])])]),t._v(" "),_("h2",{attrs:{id:"_2、uml类图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、uml类图"}},[t._v("#")]),t._v(" 2、UML类图")]),t._v(" "),_("ul",[_("li",[t._v("UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统 分析和设计的语言工具，它用于帮助软 件开发人员进行思考和记录思路的结果")]),t._v(" "),_("li",[t._v("UML本身是一套符号的规定，就像数学 符号和化学符号一样，这些符号用于描 述软件模型中的各个元素和他们之间的 关系，比如类、接口、实现、泛化、依 赖、组合、聚合等，如右图: "),_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200417104235195.png",alt:"image-20200417104235195"}})]),t._v(" "),_("li",[t._v("使用UML来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模")])]),t._v(" "),_("h3",{attrs:{id:"_2-1类之间的关系："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1类之间的关系："}},[t._v("#")]),t._v(" 2.1类之间的关系：")]),t._v(" "),_("blockquote",[_("p",[t._v("用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系")])]),t._v(" "),_("ul",[_("li",[t._v("依赖")]),t._v(" "),_("li",[t._v("泛化（继承）")]),t._v(" "),_("li",[t._v("实现")]),t._v(" "),_("li",[t._v("关联")]),t._v(" "),_("li",[t._v("聚合")]),t._v(" "),_("li",[t._v("组合")])]),t._v(" "),_("h2",{attrs:{id:"_3、-设计模式类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、-设计模式类型"}},[t._v("#")]),t._v(" 3、 设计模式类型")]),t._v(" "),_("p",[t._v("设计模式分为三种类型，共23种")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。")])]),t._v(" "),_("li",[_("p",[t._v("结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享 元模式、代理模式。")])]),t._v(" "),_("li",[_("p",[t._v("行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模 式、策略模式、职责链模式(责任链模式)。")])])]),t._v(" "),_("h3",{attrs:{id:"_3-1、单例模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1、单例模式"}},[t._v("#")]),t._v(" 3.1、单例模式")]),t._v(" "),_("ul",[_("li",[t._v("饿汉式(静态常量)")]),t._v(" "),_("li",[t._v("饿汉式（静态代码块）")]),t._v(" "),_("li",[t._v("懒汉式(线程不安全)")]),t._v(" "),_("li",[t._v("懒汉式(线程安全，同步方法)")]),t._v(" "),_("li",[t._v("懒汉式(线程安全，同步代码块)")]),t._v(" "),_("li",[t._v("双重检查")]),t._v(" "),_("li",[t._v("静态内部类")]),t._v(" "),_("li",[t._v("枚举")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("饿汉式（静态常量）")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[t._v("优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。")]),t._v(" "),_("li",[t._v("缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费")]),t._v(" "),_("li",[t._v("这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化instance就没有达到lazy loading的效果")]),t._v(" "),_("li",[t._v("结论：这种单例模式可用，可能造成内存浪费")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("饿汉式（静态代码块）")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块 中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优 缺点和上面是一样的。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("结论：这种单例模式可用，但是可能造成内存浪费")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("懒汉式(线程不安全)")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("起到了Lazy Loading的效果，但是只能在单线程下使用。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式 3) 结论：在实际开发中，不要使用这种方式")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("懒汉式(线程安全，同步方法)")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("解决了线程不安全问题")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低 3) 结论：在实际开发中，不推荐使用这种方式")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("双重检查")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次if (singleton == null)检查，这样就可以保证线程安全了。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， 直接return实例化对象，也避免的反复进行方法同步.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("线程安全；延迟加载；效率较高")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("结论：在实际开发中，推荐使用这种单例设计模")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("静态内部类")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("这种方式采用了类装载的机制来保证初始化实例时只有一个线程。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 实例化。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("结论：推荐使用.")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("枚举")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 且还能防止反序列化重新创建新的对象。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("这种方式是Effective Java作者Josh Bloch 提倡的方式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("结论：推荐使用")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-2、工厂模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2、工厂模式"}},[t._v("#")]),t._v(" 3.2、工厂模式")]),t._v(" "),_("ul",[_("li",[t._v("简单工厂模式")]),t._v(" "),_("li",[t._v("工厂方法模式")]),t._v(" "),_("li",[t._v("抽象工厂模式")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")]),t._v("：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一 个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族 中最简单实用的模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行 为(代码)")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会 使用到工厂模式")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("工厂方法模式")])])]),t._v(" "),_("p",[t._v("工厂方法模式介绍")]),t._v(" "),_("ul",[_("li",[t._v("工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点 餐子类中具体实现。")]),t._v(" "),_("li",[t._v("工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方 法模式将对象的实例化推迟到子类。")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("抽象工厂模式")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需 指明具体的类")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以 根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇， 更利于代码的维护和扩展。")])])])]),t._v(" "),_("p",[_("strong",[t._v("工厂模式小结")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("工厂模式的意义 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的 依赖关系的解耦。从而提高项目的扩展和维护性。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("设计模式的依赖抽象原")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-3、原型模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3、原型模式"}},[t._v("#")]),t._v(" 3.3、原型模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")]),t._v("：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷 贝这些原型，创建新的对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建 的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("形象的理解：孙大圣拔出猴毛， 变出其它孙大圣")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("原型模式原理结构图-uml类图：")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200417221010897.png",alt:"image-20200417221010897"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("原理结构图说明")]),t._v(" ：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Prototype : 原型类，声明一个克隆自己的接口")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)")])])])]),t._v(" "),_("p",[_("strong",[t._v("深入讨论-浅拷贝和深拷贝")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("浅拷贝的介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将 该属性值复制一份给新的对象。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类 的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内 存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个 实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成 员变量值")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("前面我们克隆羊就是浅拷贝")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("浅拷贝是使用默认的 clone()方法来实现 sheep = (Sheep) super.clone();")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("深拷贝基本介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("复制对象的所有基本数据类型的成员变量值")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变 量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对 整个对象进行拷贝。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("深拷贝实现方式1：重写clone方法来实现深拷贝")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("原型模式的注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提 高效率")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("不用重新初始化对象，而是动态地获得对象运行时的状态")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化， 无需修改代码")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("在实现深克隆的时候可能需要比较复杂的代码")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有 的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意.")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-4、建造者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4、建造者模式"}},[t._v("#")]),t._v(" 3.4、建造者模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以 将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方 法可以构造出不同表现（属性）的对象。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象 的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("建造者模式的四个角色：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Product（产品角色）： 一个具体的产品对象。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("Builder（抽象建造者）： 创建一个Product对象的各个部件指定的 接口/抽象类。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("Director（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个 复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是： 负责控制产品对象的生产过程")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("建造者模式原理类图")]),t._v("：")])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200417221339283.png",alt:"image-20200417221339283"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("建造者模式的注意事项和细节")]),t._v("：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解 耦，使得相同的创建过程可以创建不同的产品对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替 换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同 的产品对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法 中，使得创建过程更加清晰，也更方便使用程序来控制创建过程")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程， 系统扩展方便，符合 “开闭原则”")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-5、适配器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5、适配器模式"}},[t._v("#")]),t._v(" 3.5、适配器模式")]),t._v(" "),_("p",[_("strong",[t._v("基本介绍")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表 示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同 工作。其别名为包装器(Wrapper)")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("适配器模式属于结构型模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("主要分为三类：类适配器模式、对象适配器模式、接口适配器模式")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("适配器模式工作原理：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼 容")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("从用户的角度看不到被适配者，是解耦的")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口 方法")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("用户收到反馈结果，感觉只是和目标接口交互，如图")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200418094510964.png",alt:"image-20200418094510964"}})]),t._v(" "),_("p",[_("strong",[t._v("类适配器模式")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("类适配器模式介绍：")])])]),t._v(" "),_("ul",[_("li",[t._v("Adapter类，通过继承 src类，实现 dst 类接口，完成src->dst的适配。")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("类适配器模式注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要 求dst必须是接口，有一定局限性;")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("src类的方法在Adapter中都会暴露出来，也增加了使用的成本。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵 活性增强了。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("类适配器模式注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要 求dst必须是接口，有一定局限性;")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("src类的方法在Adapter中都会暴露出来，也增加了使用的成本。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵 活性增强了")])])])]),t._v(" "),_("p",[_("strong",[t._v("对象适配器模式")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("对象适配器模式介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而 是持有src类的实例，以解决兼容性的问题。 即：持有 src类，实现 dst 类接口， 完成src->dst的适配")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("对象适配器模式是适配器模式常用的一种")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("对象适配器模式注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承src的 局限性问题，也不再要求dst必须是接口。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("使用成本更低，更灵活。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("接口适配器模式介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接 口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆 盖父类的某些方法来实现需求")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("适用于一个接口不想使用其所有的方法的情况。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("适配器模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来 命名的。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("类适配器：以类给到，在Adapter里，就是将src当做类，继承 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("实际开发中，实现起来不拘泥于我们讲解的三种经典形式")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-6、桥接模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-6、桥接模式"}},[t._v("#")]),t._v(" 3.6、桥接模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层 次可以独立改变。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("是一种结构型设计模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同 的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现 (Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能 扩展")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("桥接模式原理类图：")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200418104355271.png",alt:"image-20200418104355271"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("原理类图说明：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Client类：桥接模式的调用者")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("抽象类(Abstraction) :维护了 Implementor / 即它的实现类ConcreteImplementorA.., 二者是聚合关系, Abstraction 充当 桥接类")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("桥接模式的注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实 现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部 分由具体业务来完成。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层， 要求开发者针对抽象进行设计和编程 5) 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局 限性，即需要有这样的应用场景")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-7、装饰者设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-7、装饰者设计模式"}},[t._v("#")]),t._v(" 3.7、装饰者设计模式")]),t._v(" "),_("h3",{attrs:{id:"_3-8、组合模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-8、组合模式"}},[t._v("#")]),t._v(" 3.8、组合模式")]),t._v(" "),_("blockquote",[_("p",[t._v("基本介绍：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结 构，将对象组合成树状结构以表示“整体-部分”的层次关系。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 3) 这种类型的设计模式属于结构型模式。 4) 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客 户以一致的方式处理个别对象以及组合对象理结构图的说明-即(组合模式的角色及职责)")])])])]),t._v(" "),_("blockquote",[_("p",[t._v("组合模式的原理类图：")])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210536399.png",alt:"image-20200510210536399"}})]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子 部件, Component 可以是抽象类或者接口")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("Leaf : 在组合中表示叶子节点，叶子节点没有子节点")])])])]),t._v(" "),_("p",[_("strong",[t._v("解决的问题")])]),t._v(" "),_("blockquote",[_("p",[t._v("组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而 我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑 它是节点还是叶子 2) 对应的示意图")])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210610447.png",alt:"image-20200510210610447"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("组合模式在JDK集合的源码分析")])])]),t._v(" "),_("p",[_("strong",[t._v("组合模式在JDK集合的源码分析：")]),t._v("\nJava的集合类-HashMap就使用了组合模式 2) 代码分析+Debug 源码")]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210709009.png",alt:"image-20200510210709009"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("组合模式的注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子 的问题。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系， 客户端不用做出任何改动.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点 或者叶子从而创建出复杂的树形结构")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性 都不一样，不适合使用组合模式")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-9、外观模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-9、外观模式"}},[t._v("#")]),t._v(" 3.9、外观模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")])])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供 一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加 容易使用")])]),t._v(" "),_("li",[_("p",[t._v("外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端 只需跟这个接口发生调用，而无需关心这个子系统的内部细节")])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("外观模式原理类图")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当 子系统对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("调用者(Client): 外观接口的调用者")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210920073.png",alt:"image-20200510210920073"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("外观模式在MyBatis框架应用的源码分析")])])]),t._v(" "),_("ol",[_("li",[t._v("MyBatis 中的Configuration 去创建MetaObject 对象使用到外观模式 2) 代码分析+Debug源码+示意图")])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510210954986.png",alt:"image-20200510210954986"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("外观模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复 杂性")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("通过合理的使用外观模式，可以帮我们更好的划分访问的层次")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("当系统需要进行分层设计时，可以考虑使用Facade模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时 可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 让新系统与Facade类交互，提高复用性")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"6"}},[_("li",[t._v("不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。 要以让系统有层次，利于维护为目的")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-10、享元模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-10、享元模式"}},[t._v("#")]),t._v(" 3.10、享元模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("享元模式（Flyweight Pattern） 也叫 蝇量模式: 运 用共享技术有效地支持大量细粒度的对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("常用于系统底层开发，解决系统的性能问题。像 数据库连接池，里面都是创建好的连接对象，在 这些连接对象中有我们需要的则直接拿来用，避 免重新创建，如果没有我们需要的，则创建一个")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("享元模式能够解决重复对象的内存浪费的问题， 当系统中有大量相似对象，需要缓冲池时。不需 总是创建新对象，可以从缓冲池里拿。这样可以 降低系统内存，同时提高效率")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("享元模式经典的应用场景就是池技术了，String常 量池、数据库连接池、缓冲池等等都是享元模式 的应用，享元模式是池技术的重要实现方式")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510221232579.png",alt:"image-20200510221232579"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("享元模式的原理类图")])])]),t._v(" "),_("p",[t._v("对原理图的说明-即(模式的角色及职责)")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czhanb%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200510221247213.png",alt:"image-20200510221247213"}})]),t._v(" "),_("p",[_("strong",[t._v("内部状态和外部状态")])]),t._v(" "),_("p",[t._v("比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一 点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后， 落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态 了，即将对象的信息分为两个部分：内部状态和外部状态")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对 象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用 享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解 决了对象的开销问题")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("享元模式在JDK-Interger的应用源码分析")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Integer中的享元模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("代码分析+Debug源码+说明")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"hero.png",alt:"image-20200510221328202"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("享元模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("在享元模式这样理解，“享”就表示共享，“元”表示对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时， 我们就可以考虑选用享元模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap/HashTable存储")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有 固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的 地方.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"6"}},[_("li",[t._v("使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"7"}},[_("li",[t._v("享元模式经典的应用场景是需要缓冲池的场景，比如 String常量池、数据库连接池")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-11、代理模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-11、代理模式"}},[t._v("#")]),t._v(" 3.11、代理模式")])])}),[],!1,null,null,null);l.default=a.exports}}]);