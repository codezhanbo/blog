(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{468:function(t,l,_){"use strict";_.r(l);var v=_(4),i=Object(v.a)({},(function(){var t=this,l=t.$createElement,_=t._self._c||l;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),_("h2",{attrs:{id:"_1、设计模式七大原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、设计模式七大原则"}},[t._v("#")]),t._v(" 1、设计模式七大原则")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("单一职责原则")])]),t._v(" "),_("li",[_("p",[t._v("接口隔离原则")])]),t._v(" "),_("li",[_("p",[t._v("依赖倒转(倒置)原则")])]),t._v(" "),_("li",[_("p",[t._v("里氏替换原则")])]),t._v(" "),_("li",[_("p",[t._v("开闭原则")])]),t._v(" "),_("li",[_("p",[t._v("迪米特法则")])]),t._v(" "),_("li",[_("p",[t._v("合成复用原则")])])]),t._v(" "),_("h2",{attrs:{id:"_2、uml类图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、uml类图"}},[t._v("#")]),t._v(" 2、UML类图")]),t._v(" "),_("ul",[_("li",[t._v("UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统 分析和设计的语言工具，它用于帮助软 件开发人员进行思考和记录思路的结果")]),t._v(" "),_("li",[t._v("UML本身是一套符号的规定，就像数学 符号和化学符号一样，这些符号用于描 述软件模型中的各个元素和他们之间的 关系，比如类、接口、实现、泛化、依 赖、组合、聚合等，如右图: "),_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130011.png",alt:"image-20200417104235195"}})]),t._v(" "),_("li",[t._v("使用UML来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模")])]),t._v(" "),_("h3",{attrs:{id:"_2-1类之间的关系："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1类之间的关系："}},[t._v("#")]),t._v(" 2.1类之间的关系：")]),t._v(" "),_("blockquote",[_("p",[t._v("用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系")])]),t._v(" "),_("ul",[_("li",[t._v("依赖")]),t._v(" "),_("li",[t._v("泛化（继承）")]),t._v(" "),_("li",[t._v("实现")]),t._v(" "),_("li",[t._v("关联")]),t._v(" "),_("li",[t._v("聚合")]),t._v(" "),_("li",[t._v("组合")])]),t._v(" "),_("h2",{attrs:{id:"_3、-设计模式类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、-设计模式类型"}},[t._v("#")]),t._v(" 3、 设计模式类型")]),t._v(" "),_("p",[t._v("设计模式分为三种类型，共23种")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享 元模式、代理模式。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模 式、策略模式、职责链模式(责任链模式)。")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-1、单例模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1、单例模式"}},[t._v("#")]),t._v(" 3.1、单例模式")]),t._v(" "),_("ul",[_("li",[t._v("饿汉式(静态常量)")]),t._v(" "),_("li",[t._v("饿汉式（静态代码块）")]),t._v(" "),_("li",[t._v("懒汉式(线程不安全)")]),t._v(" "),_("li",[t._v("懒汉式(线程安全，同步方法)")]),t._v(" "),_("li",[t._v("懒汉式(线程安全，同步代码块)")]),t._v(" "),_("li",[t._v("双重检查")]),t._v(" "),_("li",[t._v("静态内部类")]),t._v(" "),_("li",[t._v("枚举")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("饿汉式（静态常量）")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[t._v("优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。")]),t._v(" "),_("li",[t._v("缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费")]),t._v(" "),_("li",[t._v("这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化instance就没有达到lazy loading的效果")]),t._v(" "),_("li",[t._v("结论：这种单例模式可用，可能造成内存浪费")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("饿汉式（静态代码块）")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块 中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优 缺点和上面是一样的。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("结论：这种单例模式可用，但是可能造成内存浪费")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("懒汉式(线程不安全)")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("起到了Lazy Loading的效果，但是只能在单线程下使用。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式 3) 结论：在实际开发中，不要使用这种方式")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("懒汉式(线程安全，同步方法)")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("解决了线程不安全问题")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低 3) 结论：在实际开发中，不推荐使用这种方式")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("双重检查")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次if (singleton == null)检查，这样就可以保证线程安全了。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， 直接return实例化对象，也避免的反复进行方法同步.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("线程安全；延迟加载；效率较高")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("结论：在实际开发中，推荐使用这种单例设计模")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("静态内部类")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("这种方式采用了类装载的机制来保证初始化实例时只有一个线程。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 实例化。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("结论：推荐使用.")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("枚举")])])]),t._v(" "),_("p",[_("strong",[t._v("优缺点说明（推荐）")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 且还能防止反序列化重新创建新的对象。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("这种方式是Effective Java作者Josh Bloch 提倡的方式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("结论：推荐使用")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-2、工厂模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2、工厂模式"}},[t._v("#")]),t._v(" 3.2、工厂模式")]),t._v(" "),_("ul",[_("li",[t._v("简单工厂模式")]),t._v(" "),_("li",[t._v("工厂方法模式")]),t._v(" "),_("li",[t._v("抽象工厂模式")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")]),t._v("：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一 个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族 中最简单实用的模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行 为(代码)")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会 使用到工厂模式")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("工厂方法模式")])])]),t._v(" "),_("p",[t._v("工厂方法模式介绍")]),t._v(" "),_("ul",[_("li",[t._v("工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点 餐子类中具体实现。")]),t._v(" "),_("li",[t._v("工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方 法模式将对象的实例化推迟到子类。")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("抽象工厂模式")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需 指明具体的类")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以 根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇， 更利于代码的维护和扩展。")])])])]),t._v(" "),_("p",[_("strong",[t._v("工厂模式小结")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("工厂模式的意义 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的 依赖关系的解耦。从而提高项目的扩展和维护性。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("设计模式的依赖抽象原")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-3、原型模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3、原型模式"}},[t._v("#")]),t._v(" 3.3、原型模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")]),t._v("：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷 贝这些原型，创建新的对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建 的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("形象的理解：孙大圣拔出猴毛， 变出其它孙大圣")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("原型模式原理结构图-uml类图：")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130030.png",alt:"image-20200417221010897"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("原理结构图说明")]),t._v(" ：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Prototype : 原型类，声明一个克隆自己的接口")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)")])])])]),t._v(" "),_("p",[_("strong",[t._v("深入讨论-浅拷贝和深拷贝")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("浅拷贝的介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将 该属性值复制一份给新的对象。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类 的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内 存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个 实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成 员变量值")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("前面我们克隆羊就是浅拷贝")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("浅拷贝是使用默认的 clone()方法来实现 sheep = (Sheep) super.clone();")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("深拷贝基本介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("复制对象的所有基本数据类型的成员变量值")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变 量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对 整个对象进行拷贝。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("深拷贝实现方式1：重写clone方法来实现深拷贝")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("原型模式的注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提 高效率")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("不用重新初始化对象，而是动态地获得对象运行时的状态")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化， 无需修改代码")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("在实现深克隆的时候可能需要比较复杂的代码")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有 的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意.")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-4、建造者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4、建造者模式"}},[t._v("#")]),t._v(" 3.4、建造者模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以 将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方 法可以构造出不同表现（属性）的对象。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象 的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("建造者模式的四个角色：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Product（产品角色）： 一个具体的产品对象。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("Builder（抽象建造者）： 创建一个Product对象的各个部件指定的 接口/抽象类。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("Director（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个 复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是： 负责控制产品对象的生产过程")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("建造者模式原理类图")]),t._v("：")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130038.png",alt:"image-20200417221339283"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("建造者模式的注意事项和细节")]),t._v("：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解 耦，使得相同的创建过程可以创建不同的产品对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替 换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同 的产品对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法 中，使得创建过程更加清晰，也更方便使用程序来控制创建过程")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程， 系统扩展方便，符合 “开闭原则”")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-5、适配器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5、适配器模式"}},[t._v("#")]),t._v(" 3.5、适配器模式")]),t._v(" "),_("p",[_("strong",[t._v("基本介绍")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表 示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同 工作。其别名为包装器(Wrapper)")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("适配器模式属于结构型模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("主要分为三类：类适配器模式、对象适配器模式、接口适配器模式")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("适配器模式工作原理：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼 容")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("从用户的角度看不到被适配者，是解耦的")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口 方法")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("用户收到反馈结果，感觉只是和目标接口交互，如图")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130045.png",alt:"image-20200418094510964"}})]),t._v(" "),_("p",[_("strong",[t._v("类适配器模式")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("类适配器模式介绍：")])])]),t._v(" "),_("ul",[_("li",[t._v("Adapter类，通过继承 src类，实现 dst 类接口，完成src->dst的适配。")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("类适配器模式注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要 求dst必须是接口，有一定局限性;")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("src类的方法在Adapter中都会暴露出来，也增加了使用的成本。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵 活性增强了。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("类适配器模式注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要 求dst必须是接口，有一定局限性;")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("src类的方法在Adapter中都会暴露出来，也增加了使用的成本。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵 活性增强了")])])])]),t._v(" "),_("p",[_("strong",[t._v("对象适配器模式")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("对象适配器模式介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而 是持有src类的实例，以解决兼容性的问题。 即：持有 src类，实现 dst 类接口， 完成src->dst的适配")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("对象适配器模式是适配器模式常用的一种")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("对象适配器模式注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承src的 局限性问题，也不再要求dst必须是接口。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("使用成本更低，更灵活。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("接口适配器模式介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接 口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆 盖父类的某些方法来实现需求")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("适用于一个接口不想使用其所有的方法的情况。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("适配器模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来 命名的。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("类适配器：以类给到，在Adapter里，就是将src当做类，继承 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("实际开发中，实现起来不拘泥于我们讲解的三种经典形式")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-6、桥接模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-6、桥接模式"}},[t._v("#")]),t._v(" 3.6、桥接模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层 次可以独立改变。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("是一种结构型设计模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同 的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现 (Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能 扩展")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("桥接模式原理类图：")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130050.png",alt:"image-20200418104355271"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("原理类图说明：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Client类：桥接模式的调用者")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("抽象类(Abstraction) :维护了 Implementor / 即它的实现类ConcreteImplementorA.., 二者是聚合关系, Abstraction 充当 桥接类")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("桥接模式的注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实 现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部 分由具体业务来完成。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层， 要求开发者针对抽象进行设计和编程 5) 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局 限性，即需要有这样的应用场景")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-7、装饰者设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-7、装饰者设计模式"}},[t._v("#")]),t._v(" 3.7、装饰者设计模式")]),t._v(" "),_("h3",{attrs:{id:"_3-8、组合模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-8、组合模式"}},[t._v("#")]),t._v(" 3.8、组合模式")]),t._v(" "),_("blockquote",[_("p",[t._v("基本介绍：")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结 构，将对象组合成树状结构以表示“整体-部分”的层次关系。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 3) 这种类型的设计模式属于结构型模式。 4) 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客 户以一致的方式处理个别对象以及组合对象理结构图的说明-即(组合模式的角色及职责)")])])])]),t._v(" "),_("blockquote",[_("p",[t._v("组合模式的原理类图：")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130053.png",alt:"image-20200510210536399"}})]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子 部件, Component 可以是抽象类或者接口")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("Leaf : 在组合中表示叶子节点，叶子节点没有子节点")])])])]),t._v(" "),_("p",[_("strong",[t._v("解决的问题")])]),t._v(" "),_("blockquote",[_("p",[t._v("组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而 我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑 它是节点还是叶子 2) 对应的示意图")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130100.png",alt:"image-20200510210610447"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("组合模式在JDK集合的源码分析")])])]),t._v(" "),_("p",[_("strong",[t._v("组合模式在JDK集合的源码分析：")]),t._v("\nJava的集合类-HashMap就使用了组合模式 2) 代码分析+Debug 源码")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130103.png",alt:"image-20200510210709009"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("组合模式的注意事项和细节：")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子 的问题。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系， 客户端不用做出任何改动.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点 或者叶子从而创建出复杂的树形结构")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性 都不一样，不适合使用组合模式")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-9、外观模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-9、外观模式"}},[t._v("#")]),t._v(" 3.9、外观模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")])])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供 一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加 容易使用")])]),t._v(" "),_("li",[_("p",[t._v("外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端 只需跟这个接口发生调用，而无需关心这个子系统的内部细节")])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("外观模式原理类图")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当 子系统对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("调用者(Client): 外观接口的调用者")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130107.png",alt:"image-20200510210920073"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("外观模式在MyBatis框架应用的源码分析")])])]),t._v(" "),_("ol",[_("li",[t._v("MyBatis 中的Configuration 去创建MetaObject 对象使用到外观模式 2) 代码分析+Debug源码+示意图")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130109.png",alt:"image-20200510210954986"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("外观模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复 杂性")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("通过合理的使用外观模式，可以帮我们更好的划分访问的层次")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("当系统需要进行分层设计时，可以考虑使用Facade模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时 可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 让新系统与Facade类交互，提高复用性")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"6"}},[_("li",[t._v("不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。 要以让系统有层次，利于维护为目的")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-10、享元模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-10、享元模式"}},[t._v("#")]),t._v(" 3.10、享元模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("享元模式（Flyweight Pattern） 也叫 蝇量模式: 运 用共享技术有效地支持大量细粒度的对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("常用于系统底层开发，解决系统的性能问题。像 数据库连接池，里面都是创建好的连接对象，在 这些连接对象中有我们需要的则直接拿来用，避 免重新创建，如果没有我们需要的，则创建一个")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("享元模式能够解决重复对象的内存浪费的问题， 当系统中有大量相似对象，需要缓冲池时。不需 总是创建新对象，可以从缓冲池里拿。这样可以 降低系统内存，同时提高效率")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("享元模式经典的应用场景就是池技术了，String常 量池、数据库连接池、缓冲池等等都是享元模式 的应用，享元模式是池技术的重要实现方式")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130113.png",alt:"image-20200510221232579"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("享元模式的原理类图")])])]),t._v(" "),_("p",[t._v("对原理图的说明-即(模式的角色及职责)")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130116.png",alt:"image-20200510221247213"}})]),t._v(" "),_("p",[_("strong",[t._v("内部状态和外部状态")])]),t._v(" "),_("p",[t._v("比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一 点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后， 落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态 了，即将对象的信息分为两个部分：内部状态和外部状态")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对 象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用 享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解 决了对象的开销问题")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("享元模式在JDK-Interger的应用源码分析")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Integer中的享元模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("代码分析+Debug源码+说明")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130120.png",alt:"image-20200510221328202"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("享元模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("在享元模式这样理解，“享”就表示共享，“元”表示对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时， 我们就可以考虑选用享元模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap/HashTable存储")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有 固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的 地方.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"6"}},[_("li",[t._v("使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"7"}},[_("li",[t._v("享元模式经典的应用场景是需要缓冲池的场景，比如 String常量池、数据库连接池")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-11、代理模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-11、代理模式"}},[t._v("#")]),t._v(" 3.11、代理模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("代理模式的基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理 对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的 功能操作,即扩展目标对象的功能。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("代理模式有不同的形式, 主要有三种 静态代理、动态代理 (JDK代理、接口代 理)和 Cglib代理 (可以在内存动态的创建对象，而不需要实现接口， 他是属于 动态代理的范畴) 。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("静态代码模式的基本介绍")])])]),t._v(" "),_("p",[t._v("静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一 起实现相同的接口或者是继承相同父类，静态代理优缺点。")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("一旦接口增加方法,目标对象与代理对象都要维护")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("动态代理模式的基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("动态代理也叫做：JDK代理、接口代理")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("JDK中生成代理对象的API")])])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("代理类所在包:java.lang.reflect.Proxy")])]),t._v(" "),_("li",[_("p",[t._v("JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完 整的写法是: static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )")])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("Cglib代理模式的基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("静态代理和JDK代理模式都要求目标对象是实现一个接口,但是有时候目标对象只 是一个单独的对象,并没有实现任何的接口,这个时候可使用目标对象子类来实现 代理-这就是Cglib代理")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功 能扩展, 有些书也将Cglib代理归属到动态代理。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接 口.它广泛的被许多AOP的框架使用,例如Spring AOP，实现方法拦截")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("在AOP编程中如何选择代理模式： 1. 目标对象需要实现接口，用JDK代理 2. 目标对象不需要实现接口，用Cglib代理")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("几种常见的代理模式介绍— 几种变体")])])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("防火墙代理 内网通过代理穿透防火墙，实现对公网的访问。")])]),t._v(" "),_("li",[_("p",[t._v("缓存代理 比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源， 再到公网或者数据库取，然后缓存。")])]),t._v(" "),_("li",[_("p",[t._v("远程代理 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和 真正的远程对象沟通信息。")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130124.png",alt:"image-20200513002450830"}})]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("同步代理：主要使用在多线程编程中，完成多线程间同步工作")])]),t._v(" "),_("h3",{attrs:{id:"_3-12、模板方法模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-12、模板方法模式"}},[t._v("#")]),t._v(" 3.12、模板方法模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，z 在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法 实现，但调用将以抽象类中定义的方式进行。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子 类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定 步骤")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("这种类型的设计模式属于行为型模式。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("模板方法模式的原理类图")])])]),t._v(" "),_("p",[t._v("对原理类图的说明-即(模板方法模式的角色及职责)")]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨 架，具体子类需要去实现 其它的抽象方法operationr2,3,4")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("ConcreteClass 实现抽象方法operationr2,3,4, 以完成算法中特点子类的步 骤")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130126.png",alt:"image-20200513002554173"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("模板方法模式的钩子方法")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以 视情况要不要覆盖它，该方法称为“钩子”。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配 料，请使用钩子方法对前面的模板方法进行改造")])])])]),t._v(" "),_("p",[_("strong",[t._v("模板方法模式在Spring框架应用的源码分析")])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("Spring IOC容器初始化时运用到的模板方法模式")])]),t._v(" "),_("li",[_("p",[t._v("代码分析+角色分析+说明类图")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130129.png",alt:"image-20200513002707792"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("模板方法模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算 法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接 使用。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不 变，同时由子类提供部分步骤的实现。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加， 使得系统更加庞大")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("一般模板方法都加上final关键字， 防止子类重写模板方法.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"6"}},[_("li",[t._v("模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤 ，这一 系列的步骤基本相同，但其个别步骤在实现时 可能不同，通常考虑用模板方法模 式来处理")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-13、命令模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-13、命令模式"}},[t._v("#")]),t._v(" 3.13、命令模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("命令模式基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("命令模式（Command Pattern）：在软件设计中，我们经常需要 向某些对象发送请求，但是并不知道请求的接收者是谁，也不知 道被请求的操作是哪个， 我们只需在程序运行时指定具体的请求接收者即可，此时，可以 使用命令模式来进行设计")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让 对象之间的调用关系更加灵活，实现解耦。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("在命名模式中，会将一个请求封装为一个对象，以便使用不同参 数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色： 将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将 军和士兵)。 Invoker是调用者（将军），Receiver是被调用者（士兵）， MyCommand是命令，实现了Command接口，持有接收对象")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("命令模式的原理类图")])])]),t._v(" "),_("p",[t._v("对原理类图的说明-即(命名模式的角色及职责)")]),t._v(" "),_("ol",[_("li",[t._v("Invoker 是调用者角色")])]),t._v(" "),_("ul",[_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类")])])])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[_("p",[t._v("Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作")])]),t._v(" "),_("li",[_("p",[t._v("ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130133.png",alt:"image-20200513202404406"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("命令模式在Spring框架JdbcTemplate应用的源码分析")])])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("Spring框架的JdbcTemplate就使用到了命令模式")])]),t._v(" "),_("li",[_("p",[t._v("代码分析")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130135.png",alt:"image-20200513202435249"}})]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("模式角色分析说明")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130138.png",alt:"image-20200513202452595"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("命令模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要 调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对 象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：” 请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到 了纽带桥梁的作用。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("容易实现对请求的撤销和重做")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这 点在在使用的时候要注意")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没 有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"6"}},[_("li",[t._v("命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD（DOS命令） 订单的撤销/恢复、触发-反馈机制")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-14、访问者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-14、访问者模式"}},[t._v("#")]),t._v(" 3.14、访问者模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("访问者模式基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作， 它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("主要将数据结构与数据操作分离，解决 数据结构和操作耦合性问题")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者 的接口")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v('访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作 (这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以 选用访问者模式解决')])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("访问者模式的原理类图")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130141.png",alt:"image-20200513202612651"}})]),t._v(" "),_("p",[_("strong",[t._v("对原理类图的说明即(访问者模式的角色及职责)")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Visitor 是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("ConcreteVisitor ：是一个具体的访问值 实现每个有Visitor 声明的操作，是每个操作实现的部分.")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("ObjectStructure 能枚举它的元素， 可以提供一个高层的接口，用来允许访问者访问元素")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("Element 定义一个accept 方法，接收一个访问者对象")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("ConcreteElement 为具体元素，实现了accept 方法")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("访问者模式的注意事项和细节")])])]),t._v(" "),_("p",[_("strong",[t._v("优点")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据 结构相对稳定的系统")])])])]),t._v(" "),_("p",[_("strong",[t._v("缺点")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米 特法则所不建议的, 这样造成了具体元素变更比较困难")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问 者模式就是比较合适的.")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-15、迭代器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-15、迭代器模式"}},[t._v("#")]),t._v(" 3.15、迭代器模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("迭代器模式基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类， 或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历 方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素， 不需要知道集合对象的底层表示，即：不暴露其内部的结构。")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("迭代器模式的原理类图")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130144.png",alt:"image-20200513202701310"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("对原理类图的说明-即(迭代器模式的角色及职责)")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("ConcreteIterator : 具体的迭代器类，管理迭代")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("迭代器模式在JDK-ArrayList集合应用的源码分析")])])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("JDK的ArrayList 集合中就使用了迭代器模式")])]),t._v(" "),_("li",[_("p",[t._v("代码分析+类图+说明")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514130147.png",alt:"image-20200513202724602"}})]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("角色分析说明 - 内部类Itr 充当具体实现迭代器Iterator 的类， 作为ArrayList 内部类 - List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象 - ArrayList 是实现聚合接口List 的子类，实现了iterator() - Iterator 接口系统提供 - 迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题")])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("迭代器模式的注意事项和细节")])])]),t._v(" "),_("p",[_("strong",[t._v("优点")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以 遍历对象了。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚 合的具体组成。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任 原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集 合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变 的话，只影响到了迭代器。")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式")])])])]),t._v(" "),_("p",[_("strong",[t._v("缺点")])]),t._v(" "),_("ul",[_("li",[t._v("每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类")])]),t._v(" "),_("h3",{attrs:{id:"_3-16、观察者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-16、观察者模式"}},[t._v("#")]),t._v(" 3.16、观察者模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("观察者模式原理")])])]),t._v(" "),_("p",[t._v("观察者模式类似订牛奶业务")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("奶站/气象局：Subject")])]),t._v(" "),_("li",[_("p",[t._v("用户/第三方网站：Observer\nSubject：登记注册、移除和通知")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135052.png",alt:"image-20200514135044858"}})]),t._v(" "),_("ol",[_("li",[_("p",[t._v("registerObserver 注册")])]),t._v(" "),_("li",[_("p",[t._v("removeObserver 移除")])]),t._v(" "),_("li",[_("p",[t._v("notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用 户来取，也可能是实施推送，看具体需求定")])])]),t._v(" "),_("p",[t._v("Observer：接收输入")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135723.png",alt:"image-20200514135117776"}})]),t._v(" "),_("p",[t._v("观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为Subject， 依赖的对象为Observer，Subject通知Observer变化,比如这里的奶站是 Subject，是1的一方。用户时Observer，是多的一方。")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("观察者模式的好处")])])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除 和通知。")])]),t._v(" "),_("li",[_("p",[t._v("这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核 心类WeatherData不会修改代码，遵守了ocp原则。")])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("观察者模式在Jdk应用的源码分析")])])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("Jdk的Observable类就使用了观察者模式")])]),t._v(" "),_("li",[_("p",[t._v("代码分析+模式角色分析")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135708.png",alt:"image-20200514135205236"}})]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("模式角色分析 - Observable  的作用和地位等价于 我们前面讲过Subject - Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理Observer 的方法 add.. delete .. notify... - Observer 的作用和地位等价于我们前面讲过的 Observer, 有update - Observable 和 Observer 的使用方法和前面讲过的一样，只是Observable 是 类，通过继承来实现观察者模式")])]),t._v(" "),_("h3",{attrs:{id:"_3-17、中介者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-17、中介者模式"}},[t._v("#")]),t._v(" 3.17、中介者模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("中介者模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。 中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立 地改变它们之间的交互")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("中介者模式属于行为型模式，使代码易于维护")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("比如MVC模式，C（Controller控制器）是M（Model模型）和V（View视图）的中 介者，在前后端交互时起到了中间人的作用")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("中介者模式的原理类图")])])]),t._v(" "),_("p",[_("strong",[t._v("对原理类图的说明-即(中介者模式的角色及职责)")])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("Mediator 就是抽象中介者,定义了同事对象到中介者对象的接口")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("Colleague 是抽象同事类")])])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135713.png",alt:"image-20200514135251109"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("中介者模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构， 进行解耦")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("减少类间依赖，降低了耦合，符合迪米特原则")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-18、备忘录模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-18、备忘录模式"}},[t._v("#")]),t._v(" 3.18、备忘录模式")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("基本介绍")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内 部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保 存的状态")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情， 或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录 模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某 些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("备忘录模式属于行为型模式")])])])]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("备忘录模式的原理类图")])])]),t._v(" "),_("p",[t._v("对原理类图的说明-即 (备忘录模式的角色及职责)")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("originator : 对象(需要保存 状态的对象)")])]),t._v(" "),_("li",[_("p",[t._v("Memento ： 备忘录对象,负责 保存好记录，即Originator内部 状态")])]),t._v(" "),_("li",[_("p",[t._v("Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效 率")])]),t._v(" "),_("li",[_("p",[t._v("说明：如果希望保存多个originator对象的不同时间的状态，也可以，只需要 要 HashMap <String, 集合>")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200514135715.png",alt:"image-20200514135343721"}})]),t._v(" "),_("p",[t._v("针对前面的备忘录模式原理结构图，我们使用代码来说明一把，注意体会体现出 Caretaker 可以保存多个备忘录对象, 方便管理，提高效率。")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("备忘录模式的注意事项和细节")])])]),t._v(" "),_("ul",[_("li",[_("ol",[_("li",[t._v("给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史 的状态")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[t._v("实现了信息的封装，使得用户不需要关心状态的保存细节")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[t._v("如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定 的内存, 这个需要注意")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[t._v("适用的应用场景：1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理")])])]),t._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[t._v("为了节约内存，备忘录模式可以和原型模式配合使用")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-19、解释器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-19、解释器模式"}},[t._v("#")]),t._v(" 3.19、解释器模式")])])}),[],!1,null,null,null);l.default=i.exports}}]);