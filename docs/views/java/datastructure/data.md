---
title: 数据结构详解
date: 2020-05-10
tags:
 - 数据结构
categories: 
 - 编程基础
---
# 数据结构

**数据结构的分类**

- 线性（数组、链表、栈、队列）
  - 顺序存储（在内存中的地址是连续的）
    - 数组
  - 链式存储（在内存中的地址不一定是连续的）
    - 链表
- 非线性
  - 二维数组
  - 多维数组
  - 广义表
  - 树结构
  - 图结构

## 稀疏数组

> **基本介绍**

当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。
稀疏数组的处理方法是: 

- 1) 记录数组一共有几行几列，有多少个不同的值 
- 2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![image-20200516153315323](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516153324.png)

> **应用实例** 

- 1) 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等) 
- 2) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数 
- 3) 整体思路分析

![image-20200516153336399](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516153338.png)

## 队列

> **基本介绍**

- 1) 队列是一个有序列表，可以用数组或是链表来实现。 

- 2) 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出 

- 3) 示意图：(使用数组模拟队列示意图)

  ![image-20200516192051933](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516192053.png)



数组模拟队列思路

- 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队
  列的最大容量。 

- 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如图所示:

  ![image-20200516192204642](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516192205.png)

- 当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析 

  - 1) 将尾指针往后移：rear+1, 当 front ==rear 【空】 
  - 2) 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。 rear ==maxSize-1[队列满] 

> **问题分析并优化** 

- 1) 目前数组使用一次就不能用， 没有达到复用的效果 
- 2) 将这个数组使用算法，改进成一个环形的队列 取模：%

> **数组模拟环形队列**

对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)
分析说明： 

- 1) 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear+1)%maxSize==front 满] 

- 2) rear==front[空] 

- 3) 分析示意图:

  ![image-20200516192311530](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516192312.png)



## 链表

> **基本介绍**

链表是有序的列表，但是它在内存中是存储如下

![image-20200517114833085](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517114841.png)

**小结上图:** 

- 1) 链表是以节点的方式来存储,是链式存储 
- 2) 每个节点包含 data 域， next 域：指向下一个节点. 
- 3) 如图：发现链表的各个节点不一定是连续存储. 
- 4) 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定  单链表(带头结点) 逻辑结构示意图如下

![image-20200517114912877](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517114913.png)



> **单链表的应用实例** 

使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作。

- 1) 第一种方法在添加英雄时，直接添加到链表的尾部 思路分析示意图:![image-20200517114949618](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517114951.png)

- 2) 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 思路的分析示意图:

![image-20200517115017474](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517115019.png)

- 3) 修改节点功能 思路
  - (1) 先找到该节点，通过遍历，
  - (2)temp.name=newHeroNode.name;temp.nickname=newHeroNode.nickname 

- 4) 删除节点 思路分析的示意图

  ![image-20200517115202694](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517115203.png)

> **双向链表应用实例** 

使用带 head 头的双向链表实现 –水浒英雄排行榜  

**管理单向链表的缺点分析:** 

- 1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。 
- 2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除 时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会). 
- 3) 分析了双向链表如何完成遍历，添加，修改和删除的思路

对上图的说明: 分析 双向链表的遍历，添加，修改，删除的操作思路===》代码实现 

- 1) 遍历 方和 单链表一样，只是可以向前，也可以向后查找 
- 2) 添加 (默认添加到双向链表的最后)
  -  (1) 先找到双向链表的最后这个节点 
  - (2)temp.next=newHeroNode (3)newHeroNode.pre=temp; 
- 3) 修改 思路和 原来的单向链表一样. 
- 4) 删除 
  - (1) 因为是双向链表，因此，我们可以实现自我删除某个节点 
  - (2) 直接找到要删除的这个节点，比如 temp 
  - (3) temp.pre.next=temp.next 
  - (4)temp.next.pre=temp.pre; 

> **单向环形链表应用场景** 

Josephu(约瑟夫、约瑟夫环) 问题 Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直
到最后一个结点从链表中删除算法结束。

> **单向环形链表介绍**

![image-20200517221116537](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517221118.png)

> **Josephu 问题**

**约瑟夫问题的示意图**	

![image-20200517221135082](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517221136.png)

>  **Josephu 问题** 

Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此
产生一个出队编号的序列。

> **提示** 

用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。

 约瑟夫问题-创建环形链表的思路图解

![image-20200517221224861](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517221243.png)

约瑟夫问题-小孩出圈的思路分析图	

![image-20200517221240967](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517221246.png)

## 栈

> **栈的介绍**

- 1) 栈的英文为(stack) 
- 2) 栈是一个先入后出(FILO-FirstInLastOut)的有序列表。
- 3) 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 
- 4) 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元
  素最先删除，最先放入的元素最后删除 
- 5) 图解方式说明出栈(pop)和入栈(push)的概念

![image-20200518112724172](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518112732.png)

> **栈的应用场景** 

- 1) 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以
  回到原来的程序中。
-  2) 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆
  栈中。 
- 3) 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 
- 4) 二叉树的遍历。 
- 5) 图形的深度优先(depth 一 first)搜索法。

**栈的快速入门** 

- 1) 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，
  下面我们就用数组模拟栈的出栈，入栈等操作。 
- 2) 实现思路分析,并画出示意图

![image-20200518112750386](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518112751.png)

> **栈实现综合计算器(中缀表达式)** 

![image-20200518154907204](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518154908.png)

 **思路分析(图解)**

![image-20200518154925927](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518154927.png)

> **逆波兰计算器** 

- 1) 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果 
- 2) 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。 
- 3) 思路分析 

```
例如:(3+4)×5-6 对应的后缀表达式就是 34+5 × 6-, 针对后缀表达式求值步骤如下:
1．从左至右扫描，将 3 和 4 压入堆栈； 
2．遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，
3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈； 3．将 5 入栈； 
4．接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈； 
5．将 6 入栈； 
6．最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
```

**中缀表达式转换为后缀表达式**

大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发
中，我们需要将 中缀表达式转成后缀表达式。

> **具体步骤**

- 1) 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2； 
- 2) 从左至右扫描中缀表达式； 
- 3) 遇到操作数时，将其压 s2； 
- 4) 遇到运算符时，比较其与 s1 栈顶运算符的优先级： 
  - 1.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 
  - 2.否则，若优先级比栈顶运算符的高，也将运算符压入 s1； 
  - 3.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较； 
- 5) 遇到括号时： 
  - 1 如果是左括号“(”，则直接压入 s1 
  - 2 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 
- 6) 重复步骤 2 至 5，直到表达式的最右边 
- 7) 将 s1 中剩余的运算符依次弹出并压入 s2 
- 8) 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

> **举例说明:** 

将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下
因此结果为 :"123+4 × +5 –"

![image-20200518155225080](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518155226.png)

> **代码实现中缀表达式转为后缀表达式**

**思路分析**

![image-20200518155310849](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518155312.png)